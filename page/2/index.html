<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Simple</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="技术的终极目标是简洁">
<meta property="og:type" content="website">
<meta property="og:title" content="Simple">
<meta property="og:url" content="cedar-renjun.github.io/page/2/index.html">
<meta property="og:site_name" content="Simple">
<meta property="og:description" content="技术的终极目标是简洁">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple">
<meta name="twitter:description" content="技术的终极目标是简洁">
  
    <link rel="alternative" href="/atom.xml" title="Simple" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Do one thing and do it well</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cedar-renjun" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1995742315/profile?topnav=1&wvr=6" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/BLE4-0/" style="font-size: 10px;">BLE4.0</a> <a href="/tags/CC26xx/" style="font-size: 10px;">CC26xx</a> <a href="/tags/Debugger/" style="font-size: 12.5px;">Debugger</a> <a href="/tags/ELF/" style="font-size: 15px;">ELF</a> <a href="/tags/GPIO/" style="font-size: 10px;">GPIO</a> <a href="/tags/Hacker/" style="font-size: 12.5px;">Hacker</a> <a href="/tags/IAR/" style="font-size: 10px;">IAR</a> <a href="/tags/IDA/" style="font-size: 12.5px;">IDA</a> <a href="/tags/Jlink/" style="font-size: 10px;">Jlink</a> <a href="/tags/LPC/" style="font-size: 10px;">LPC</a> <a href="/tags/M1/" style="font-size: 10px;">M1</a> <a href="/tags/NFC/" style="font-size: 12.5px;">NFC</a> <a href="/tags/NXP/" style="font-size: 10px;">NXP</a> <a href="/tags/Nucleo/" style="font-size: 10px;">Nucleo</a> <a href="/tags/PN532/" style="font-size: 10px;">PN532</a> <a href="/tags/QT/" style="font-size: 12.5px;">QT</a> <a href="/tags/RFID/" style="font-size: 10px;">RFID</a> <a href="/tags/STM32/" style="font-size: 10px;">STM32</a> <a href="/tags/STM32F4/" style="font-size: 10px;">STM32F4</a> <a href="/tags/STM32F7/" style="font-size: 10px;">STM32F7</a> <a href="/tags/TI/" style="font-size: 10px;">TI</a> <a href="/tags/USB/" style="font-size: 20px;">USB</a> <a href="/tags/VS2013/" style="font-size: 10px;">VS2013</a> <a href="/tags/elua/" style="font-size: 10px;">elua</a> <a href="/tags/lua/" style="font-size: 10px;">lua</a> <a href="/tags/sublime-text/" style="font-size: 10px;">sublime text</a> <a href="/tags/公司/" style="font-size: 10px;">公司</a> <a href="/tags/微信订阅号/" style="font-size: 17.5px;">微信订阅号</a> <a href="/tags/树莓派/" style="font-size: 12.5px;">树莓派</a> <a href="/tags/示波器/" style="font-size: 10px;">示波器</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.miaoxiong.net/">喵兄</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://ahnniu.github.io/">牛工</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Cedar, 嵌入式软件工程师，玩过各种MCU，熟悉无线协议栈，USB，RTOS，半个软件架构师，最近在折腾调试器. QQ: 819280802</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Do one thing and do it well</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Do one thing and do it well</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cedar-renjun" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1995742315/profile?topnav=1&wvr=6" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-usb-re-enum" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/28/usb-re-enum/" class="article-date">
  	<time datetime="2015-11-28T11:41:57.000Z" itemprop="datePublished">2015-11-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/28/usb-re-enum/">USB 重枚举</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基本思路：拉低DP信号，保持一定时间，然后释放</p>
<p>在STM32上的用法为：</p>
<ol>
<li>关闭USB电源</li>
<li>配置DP脚，拉低</li>
<li>延时一段时间，释放DP脚</li>
<li>重新配置USB</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-usb-suspended" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/25/usb-suspended/" class="article-date">
  	<time datetime="2015-11-25T14:35:29.000Z" itemprop="datePublished">2015-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/25/usb-suspended/">usb suspended</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Q: USB设备进入暂停模式的条件是？<br>A: 总线上，3ms空闲状态，即让设备进入暂停模式</p>
<p>Q: USB设备如何退出暂停模式？<br>A: USB任意的总线活动，都会让USB设备退出休眠状态，但一般情况来说，虽然USB<br>Device会产生唤醒中断，但软件层面硬件检查DP，DM的电平值，从而确定是干扰还是HOST唤醒事件</p>
<p>Q: 退出暂停模式后，需要重新进行配置么？<br>A: 不需要，因为在暂停时，已经保存了内部状态，比如端点信息和地址信息；在恢复时，只需要恢复时钟和对应外设功能就好</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-usb-recognition-produce" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/22/usb-recognition-produce/" class="article-date">
  	<time datetime="2015-11-21T16:33:55.000Z" itemprop="datePublished">2015-11-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/22/usb-recognition-produce/">USB 插入动作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>USB 设备插入</li>
<li>HUB 通过检测DP/DM电平变化，识别出USB插入动作</li>
<li>HUB 等待100ms左右，等待设备供电稳定和初始化完成</li>
<li>HUB 请求 Device复位，Device进入默认状态，此时最大可用电流为100ma</li>
<li>HUB 分配唯一地址给Device</li>
<li>HUB 发送设备请求命令，获取Device属性和功能</li>
<li>HUB 根据实际情况，返回配置信息，配置Device，Device完成配置</li>
<li>Device处于可用状态，开始正常传输数据</li>
<li>Device设备拔出，HUB回收地址，更新逻辑树结构，通知HOST</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-why-use-required-device-reset-when-plugin" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/22/why-use-required-device-reset-when-plugin/" class="article-date">
  	<time datetime="2015-11-21T16:07:10.000Z" itemprop="datePublished">2015-11-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/22/why-use-required-device-reset-when-plugin/">为什么USB协议中，检测到设备插入时，要求复位</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为USB属于可插拔设备，这种特性就要求设备不具备记忆的特性，也就是有限状态机特性。<br>为了确保状态可控，所以就要求设备复位，从而</p>
<ol>
<li>确保HUB检测到设备拔出时，能及时回收地址</li>
<li>确保USB设备在插入HUB端口时，能进入一个确定的状态，消除旧环境的影响</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-kill-your-self-in-CC25xx-CC24xx-SOC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/08/kill-your-self-in-CC25xx-CC24xx-SOC/" class="article-date">
  	<time datetime="2015-11-07T16:58:35.000Z" itemprop="datePublished">2015-11-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/08/kill-your-self-in-CC25xx-CC24xx-SOC/">编写自杀式代码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>在制作TI调试器时，需要在RAM中执行代码，并擦除原有固件，然后接收调试器发来的数据文件，写入FLASH中，从而完成系统烧写和调试功能</p>
<p>该技术可以用作自杀式入侵代码，完成工作后，清除所有代码信息，然后重启<br>已经测试通过，并十分有效，简单的说一下基本思路，详细信息不便透露</p>
<h3 id="1_基本步骤">1    基本步骤</h3><ol>
<li>调试器连接MCU</li>
<li>更新固件</li>
<li>完成系统初始化和C－Runtime初始化</li>
<li>映射RAM执行缓冲区，设置断点</li>
<li>执行RAM函数，使用DMA擦除固件信息，准备接收调试器发送的数据资料</li>
</ol>
<h3 id="2_特别说明">2    特别说明</h3><ol>
<li>我已经在用STM32来调试CC25xx/CC23xx系列芯片，同时具备烧写功能</li>
<li>该技术可以和缓冲区漏洞结合起来，得到系统固件，并擦除自身，完全不留任何作案信息</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Debugger/">Debugger</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Learn-CC26xx-with-me-lesson-00" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/05/Learn-CC26xx-with-me-lesson-00/" class="article-date">
  	<time datetime="2015-11-04T17:37:05.000Z" itemprop="datePublished">2015-11-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/05/Learn-CC26xx-with-me-lesson-00/">跟我学蓝牙4.0之－CC26xx系列教程－00</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_认识TI_SimpleLink_系列">0    认识TI SimpleLink 系列</h3><p>TI的无线产品线非常丰富，从低频RFID/NFC，到Sub－1G系列，再到BLE4.0，Zigbee，Wi-Fi等各种芯片，应有尽有，足以满足您苛刻的应用场景。<br>可以细分为以下几个系列</p>
<ol>
<li>RF430<br>13.56MHz NFC/RFID SOC 解决方案</li>
<li>CC430<br>Sub-1G 工业无线网络解决方案</li>
<li>SimpleLink CC1x<br>最新一代的Sub－1G SOC 解决方案，采用最新RF内核，功耗更低，性能更加强劲</li>
<li>SimpleLink CC2x<br>新一代2.4G 解决方案，可用于BLE4.0，Zigbee协议栈</li>
<li>SimpleLink CC3x<br>Wi-Fi SOC解决方案，双核架构，内置TCP／IP协议栈，性能最高，已通过FCC, IC, CE and TELEC认证</li>
</ol>
<p>随着物联网的到来，SOC无线芯片已经是一个趋势，但射频开发中，还是会出现很多问题：</p>
<ol>
<li>天线设计门槛很高，需要精通射频知识</li>
<li>无线协议栈学习成本过高</li>
<li>多种软件协议标准，应用层软件不兼容</li>
</ol>
<p>针对上面的问题，TI推出<code>SimpleLink</code>系列无线芯片，在软件层面上兼容现有的无线协议，从而达到学会一种CC系列芯片，掌握全系列的无线的效果；<br>同时，TI提供很多天线参考设计，完完全全的交钥匙(Turn-Key)方案，用户可以直接使用这些参考设计，从而加速产品上市</p>
<h3 id="1_认识TI_CC26xx系列">1    认识TI CC26xx系列</h3><p>我们的重点是来学习TI CC26xx 2.4G无线蓝牙4.0产品系列，TI将CC2x系列细分为以下三种</p>
<ol>
<li>CC2630系列<br>802.15.4 MESH解决方案，用于实现Zigbee或者6LoWPAN MESH网络</li>
<li>CC2640系列<br>2.4G 蓝牙4.1系列芯片</li>
<li>CC2650系列<br>全能芯片，兼容CC2630/CC2640，能实现蓝牙4.0／Zigbee／6LoWPAN协议，从而实现一个芯片多种协议</li>
</ol>
<h3 id="2_开发环境和开发工具">2    开发环境和开发工具</h3><p>TI CC26xx支持很多IDE开发工具，具体包括：</p>
<ol>
<li>IAR</li>
<li>CCS</li>
<li>MDK</li>
<li>GCC</li>
<li>BLE Studuio</li>
</ol>
<p>更多工具信息，请参考<a href="http://processors.wiki.ti.com/index.php/CC13xx_CC26xx_Tools_Overview" target="_blank" rel="external">wiki－开发工具页面</a></p>
<p>这么多工具，我们学习CC26xx时，该怎么选呢？<br>我们推荐</p>
<ol>
<li>IAR 7.4</li>
<li>XDS110</li>
</ol>
<p>因为TI官方协议栈，都是用IAR来管理工程的，所以安装IAR能为我们的学习避免很多潜在的问题<br>另外，XDS110的调试速度很快，不会像某些Jlink一样，总是丢失固件</p>
<p>总之一句话：我们是学习蓝牙4.0的，要选择稳定的工具，不要把精力浪费在调试工具上</p>
<p>下一篇，我们将介绍怎么安装IAR和TI蓝牙4.0协议栈</p>
<h3 id="3_参考资料">3    参考资料</h3><ol>
<li><a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/wireless_mcus/overview.page" target="_blank" rel="external">TI SimpleLink</a></li>
<li><a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/wireless_mcus/simplelink_cc1x/overview.page" target="_blank" rel="external">CC1x 系列</a></li>
<li><a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/wireless_mcus/simplelink_cc2x/overview.page" target="_blank" rel="external">CC2x 系列</a></li>
<li><a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/wireless_mcus/simplelink_cc3x/overview.page" target="_blank" rel="external">CC3x 系列</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BLE4-0/">BLE4.0</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CC26xx/">CC26xx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TI/">TI</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-parallel-technology-in-programmer" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/05/parallel-technology-in-programmer/" class="article-date">
  	<time datetime="2015-11-04T16:53:35.000Z" itemprop="datePublished">2015-11-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/05/parallel-technology-in-programmer/">烧录器中的并行技术</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>利用RTOS的并行技术，我们能充分的发挥宿主MCU的性能，从而最大程度的提高程序烧写速度</p>
<h3 id="1_理论基础">1    理论基础</h3><ol>
<li>烧写器的烧写速度瓶颈不在于传输速率</li>
<li>CPU在DMA烧写FLASH的同时，可以在RAM中同时接收数据</li>
<li>一个FLASH控制器，只允许一个DMA操作</li>
</ol>
<h3 id="2_基本思路">2    基本思路</h3><ol>
<li>采用RAM FIFO机制，假设为A，B Block</li>
<li>先填充A，然后启动DMA，开始烧录扇区1</li>
<li>填充B，等待扇区1烧录完毕，配置DMA，烧录扇区2</li>
<li>填充A，等待扇区2烧录完毕，然后配置DMA</li>
<li>重复3.4步骤，直到完成</li>
</ol>
<h3 id="3_注意事项">3    注意事项</h3><ol>
<li>可以根据DMA的速率和系统总线速率，调整Block的大小和数据，从而尽可能的让DMA接近全负荷运行，从而达到理论FLASH理论烧写速率</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Debugger/">Debugger</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-elf-format-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/02/elf-format-3/" class="article-date">
  	<time datetime="2015-11-02T10:21:08.000Z" itemprop="datePublished">2015-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/02/elf-format-3/">ELF文件分析之3 － 动态链接</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述">概述</h3><p>相对于静态链接，动态链接和加载机制更加复杂，但对于系统来说，动态加载能更节省内存和其它计算资源</p>
<p>这里面涉及到的主要技术点为：</p>
<ol>
<li>GOT表</li>
<li>PLT表</li>
<li>延迟绑定</li>
</ol>
<p>基本过程为</p>
<ol>
<li>调用系统加载程序</li>
<li>调用程序所需要的动态库，并分配程序段地址</li>
<li>进行初始化，构建运行时环境（Run Time)</li>
<li>运行程序，第一次遇到动态未定义符号时，调用动态解析函数，找到符号地址，将信息写入绑定表</li>
<li>第二次调用符号时，直接进入查找表，调用对应函数</li>
</ol>
<p>所以，下面，分别介绍GOT和PLT，然后用实例来分析函数符号动态加载机制</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/">ELF</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/11/02/elf-format-3/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-elf-format-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/02/elf-format-2/" class="article-date">
  	<time datetime="2015-11-02T07:09:22.000Z" itemprop="datePublished">2015-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/02/elf-format-2/">ELF文件分析之2 － 静态链接</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_概述">0    概述</h3><p>有了上面两篇文章的铺垫，再看一遍ELF1.1规范，就已经简单的入门了<br>这篇文章，主要讲静态链接中的符号重定向过程和ELF处理机制</p>
<h3 id="2_变量内存分布">2    变量内存分布</h3><p>我们知道，C语言的变量按作用域来分，包括：</p>
<ol>
<li>全局作用域变量<br>未加static修饰的变量，这种变量会标记为PUBLIC，并对外可见</li>
<li>文件作用域变量<br>static修饰的变量，这种变量会标记为LOCAK，对外不可见</li>
<li>局部作用域变量<br>block里面的变量<br>什么是block呢，就是包含在<code>{}</code>里面的，未被static修饰的变量，这种变量会放在栈中，没有任何标记，对外不可见</li>
</ol>
<p>也许你会问，C语言中有很多类型的变量，比如int，char，enum等，你为什么只提变量，而不提具体类型？<br>这是因为，变量类型仅仅对高级语言有效，机器码里面并没有数据类型，CPU只认识特定宽度的数据，然后做基本运算。<br>真的，在ELF里面，只有<code>OBJECT</code>,<code>FUNC</code>两种类型符号，我们来尝试一下</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/">ELF</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/11/02/elf-format-2/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-elf-format-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/01/elf-format-1/" class="article-date">
  	<time datetime="2015-11-01T15:13:07.000Z" itemprop="datePublished">2015-11-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/01/elf-format-1/">ELF文件分析之1 － 文件格式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>上一篇，我们知道了ELF文件是什么，以及怎么用，本篇重点介绍ELF的文档规范</p>
<h3 id="1_整体结构">1    整体结构</h3><p>ELF适用于3种文件结构</p>
<ol>
<li>重定向文件<br>也就是经常见到的<code>.o</code>文件，用于保存代码和数据，链接器用使用这个文件来创建<code>可执行文件</code>或者<code>共享文件</code></li>
<li>可执行文件<br>也就是linux下面的<code>.out</code>文件，用于执行</li>
<li>共享文件<br>常见的静态库<code>.lib</code>或者动态库<code>.so</code>，就是这个文件格式，就是由多个<code>.o</code>压缩成的，可以用于保存代码或者数据，节省编译时间</li>
</ol>
<p>上面三种文件，再综合一下，可以分为两种</p>
<ol>
<li>链接文件（中间态）</li>
<li>可执行文件（最终态）</li>
</ol>
<p>ELF分别用两种视图来表示二者，如下所示<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/">ELF</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/11/01/elf-format-1/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-elf-format-0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/31/elf-format-0/" class="article-date">
  	<time datetime="2015-10-31T15:11:22.000Z" itemprop="datePublished">2015-10-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/31/elf-format-0/">ELF文件分析之0 － 简介和分析工具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>几年前，在读大学时，刚接触linux的时候，就对计算机的运行原理比较感兴趣，网上找了《CSAPP》和《程序员的自我修养－链接，库》，无奈当时能力不足，<br>看不懂这些，后面工作了，一直从事嵌入式偏底层的工作，比较熟悉gcc和linker，刚好最近研究hacker和工程需要，就耐着性子研究了ELF文件结构，遇到问题<br>不少，最终也解决了，所以写到blog记录一下，免得忘记</p>
<h3 id="1_概述">1    概述</h3><p>因为ELF涉及的东西比较多，所以分为4篇来介绍</p>
<ol>
<li>ELF简介和分析工具<br>主要介绍ELF的基本知识和讲解ELF分析工具的基本用法</li>
<li>ELF文件格式分析<br>主要介绍ELF文件格式</li>
<li>ELF静态链接<br>主要分析静态链接中需要解决的问题，以及基本原理</li>
<li>ELF动态链接<br>主要分析动态链接中需要解决的问题，以及基本原理</li>
</ol>
<p>OK, 进入正题<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/">ELF</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/31/elf-format-0/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-something-about-crack-m1-card" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/something-about-crack-m1-card/" class="article-date">
  	<time datetime="2015-10-27T15:08:40.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/something-about-crack-m1-card/">破解M1卡</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_概述">0    概述</h3><p>本文主要介绍破解M1卡所需要的工具和基本思路和注意事项，不会讲述详细的步骤<br>如果对此有兴趣，想深入研究，请搜索关键词<code>nfc-tools</code>, <code>libnfc</code>, <code>mfoc</code></p>
<h3 id="1_基本思路">1    基本思路</h3><ol>
<li>尝试默认密码</li>
<li>尝试常用密码</li>
<li>逐个扇区的尝试，发现某个扇区内有默认密码，则可以根据M1加密算法漏洞来分析出其它扇区的密码</li>
<li>如果扇区没有默认密码，则软件破解失败；可以尝试用软件无线电来监听通讯过程，分析密码或者重放攻击</li>
</ol>
<h3 id="2_工具">2    工具</h3><ol>
<li>PN532或者ACR322</li>
<li><a href="http://www.hackrf.net/" target="_blank" rel="external">HackRF</a></li>
<li>libnfc和mfoc</li>
<li>树莓派或者类似的linux系统<a href="https://www.kali.org/news/kali-linux-software-defined-radio-support/" target="_blank" rel="external">kali</a></li>
</ol>
<h3 id="3_其它">3    其它</h3><ol>
<li><p>能破解公交卡么<br>我尝试了下，无法破解，全部扇区加密，估计也有服务器验证机制<br>回头尝试暴力破解试试</p>
</li>
<li><p>SDR是什么<br>经常有人问SDR是什么，这里解释下：SDR全称Software Defined Radio, 表示软件无线电，可以用软件＋FPGA来模拟10M-6GHz的射频信号， 从而用软件协议来实现硬件射频芯片功能</p>
</li>
</ol>
<p>常用的软件无线电工具有</p>
<ol>
<li><a href="http://www.rtl-sdr.com/" target="_blank" rel="external">http://www.rtl-sdr.com/</a></li>
<li><a href="http://www.hackrf.net/" target="_blank" rel="external">http://www.hackrf.net/</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M1/">M1</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NFC/">NFC</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-IDA-Pro-Reading-note-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/IDA-Pro-Reading-note-1/" class="article-date">
  	<time datetime="2015-10-27T14:38:33.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/IDA-Pro-Reading-note-1/">IDA Pro学习笔记－1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_概述">0 概述</h3><p>本文主要介绍常用的，简单的逆向和反汇编工具</p>
<h3 id="1_分类工具">1    分类工具</h3><p>在遇到一个新文件时，我们需要知道，这是一个什么类型的文件；记得，看后缀名来判断是不准确的，下面的几个工具，用来帮助你检验文件类型</p>
<ol>
<li><p>file<br>Linux下面的命令行工具，可以利用后缀名，文件头的特征码，文件开头的特殊命令行来判断类型，能识别绝大多数的文件类型</p>
</li>
<li><p>PE Tools<br>一组用于分析windows系统中正在运行的进程和可执行文件的工具。能捕获进程，并将内存映像转储，然后用PE<br>sniffer来分析可执行文件是由何种编译器构建的</p>
</li>
<li><p>PEiD<br>windows工具，用于识别构建EXE文件所有的编译器，并确定混淆代码的工具类型</p>
</li>
</ol>
<h3 id="2_摘要工具">2    摘要工具</h3><p>在分析到类型后，我们就需要分析文件内的详细信息，下面这些工具就该派上用场了</p>
<ol>
<li><p>nm<br>显示出目标文件中的所有符号；我们知道，obj文件里面都有很多符号段，用于存储符号信息，nm就可以将这些信息给打印出来，便于分析</p>
</li>
<li><p>ldd<br>用于解析静态链接或者动态链接的库信息</p>
</li>
<li><p>objdump<br>大而全的工具，用于显示目标文件的所有信息，比如节头部，专用头部，调试信息，符号信息，反汇编代码等<br>还有一个readelf工具，也有同样的功能；<br>二者的区别是：objdump依赖于libbfd，readelf不依赖libbfd</p>
</li>
<li><p>otool<br>mac OS X底下的objdump工具</p>
</li>
<li><p>dumpbin<br>VS套件里面的一个工具，功能类似objdump和ldd</p>
</li>
<li><p>C++filt<br>C＋＋会将重载函数进行重命名（name－mangling），从而保证符号唯一性，但这样为我们理解反编译函数名称造成了困难，filt就是复原原始函数名用的<br>，比如<code>nm a.out | grep demo | c++filt</code>就可以复原a.out里面所有的demo函数名</p>
</li>
</ol>
<h3 id="3_深度监测工具">3    深度监测工具</h3><ol>
<li><p>strings<br>用于提取文件中的字符串内容，我们经常在windows里面可以看到提示性文字，通过这个工具，我们就知道文字的位置，然后反向找出调用文字的程序<br>代码，最后修改代码即可<br>但是记住，不要用文字信息来推断程序功能</p>
</li>
<li><p>反汇编器<br>X86架构下的ndisasm和diStorm可以用来反汇编代码和数据</p>
</li>
</ol>
<h3 id="4_最后">4    最后</h3><p>这些工具很基础，都是linux下的常用工具，应该掌握</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hacker/">Hacker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDA/">IDA</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-IDA-Pro-Reading-note-0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/IDA-Pro-Reading-note-0/" class="article-date">
  	<time datetime="2015-10-27T03:48:20.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/IDA-Pro-Reading-note-0/">IDA Pro学习笔记－0</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_概述">0    概述</h3><p><a href="https://www.hex-rays.com/index.shtml" target="_blank" rel="external">IDA</a>，懂的人自然懂，不懂的人请百度<br>这里不做过多介绍</p>
<p>本篇作为学习笔记的第一篇，主要介绍反汇编的理论和常见反汇编方式</p>
<h3 id="1_反汇编简介">1    反汇编简介</h3><p>编程语言进化过程为：二进制－》汇编－》C／C++等编译语言－》python等动态脚本语言<br>二进制的，可以直接看ARM Thumb2指令集手册，里面有对应的编码介绍，汇编就是ARM中常见的启动代码，<br>C／python之类的，都是程序员常见的语言，都很熟悉，不多介绍</p>
<h3 id="2_为什么要反汇编">2    为什么要反汇编</h3><p>反汇编的意义在于，很多时候，我们并不能拿到C级别的源码，只能拿到bin格式的固件，所以需要通过bin来反向成汇编代码，然后分析程序<br>其它的几个原因</p>
<ol>
<li>分析恶意软件</li>
<li>分析闭源软件的漏洞</li>
<li>分析闭源软件的互操作性</li>
<li>分析编译器生成代码，以验证编译器性能和准确性</li>
<li>在调试时显示程序指令</li>
</ol>
<h3 id="3_反汇编的困难">3    反汇编的困难</h3><p>理论上来讲，bin属于透明代码，大神可以直接看二进制格式，但这么做效率太低，所以很多人做了工具，IDA就是其中一种，虽然有了工具，<br>但分析过程，仍然困难重重，原因如下</p>
<ol>
<li>编译过程会造成损失<br>bin是给机器看的，所以它不需要任何变量或者函数，但我们需要，所以变量类型只能通过分析，才能知道具体类型<br>现在ARM Thumb2指令集稍微好一点，会固化各种符号和类型，方便分析一些</li>
<li>编译属于多对多操作<br>主要是因为编译优化，或者故意混淆的手段，或者IAR编译时，没有生成符号表，从而导致缺乏一些分析辅助信息</li>
<li>反编译器依赖于语言和库<br>选对反编译器，才能正确反编译</li>
<li>反编译任何错误，都会影响反编译生成的效果</li>
</ol>
<h3 id="4_如何反汇编">4    如何反汇编</h3><p>最简单的工具，可以用各种IDE里面的binary工具，比如elfdump，直接导出符号表和汇编代码<br>但这种太简单了，不便于大型系统分析</p>
<p>理论上，反汇编的过程如下</p>
<ol>
<li><p>确定反汇编的代码区域<br>这个要看具体文件格式，比如elf之类的，直接包含各种section，可以分析<br>但bin，就要区分哪些是代码，哪些是数据，这是一个难点<br>我们可以换一个方向来看，对于STM32或者ARM Cortex系列的芯片来说，入口是固定的，我们直接找程序入口就可以了</p>
</li>
<li><p>找到入口地址，开始逐条分析<br>这里，可能需要进行表查找来获取数据；对应C语言来说，就是字符串表，变量表或者函数表</p>
</li>
<li><p>找到操作符和操作数，反编译成汇编指令</p>
</li>
<li><p>继续反汇编下一条指令</p>
</li>
</ol>
<h3 id="5_反汇编算法">5    反汇编算法</h3><p>主要有两种，也很简单</p>
<ol>
<li>线性法</li>
<li>递归下降法</li>
</ol>
<p><strong>线性法</strong>：就是逐条分析汇编，读取操作码，读取操作数，反汇编，然后下一条指令；理论上很简单，但容易出错，比如，我故意在汇编指令中<br>插入一些混淆数据，就可以扰乱反汇编器的输出；它的好处在于，能分析出所有的二进制代码<br>GDB和dbjdump都是采用线性分析法，他们因为有elf的各种辅助信息，在有代码的基础上调试，所以能知道哪些是有效数据，有效代码</p>
<p><strong>递归下降法</strong>：则是从另外一个方向来反汇编，就是从程序入口地址，然后分析下一条指令，顺序指令则直接继续分析，分支指令，比如if或者switch，则<br>直接分成两个反编译方向，依次反编译；或者跳转指令，就跳转到对应到地址。<br>也就是说，反编译器会尝试理解bin程序流，然后给出最佳的反汇编代码，但这样，也会有问题，机器毕竟是机器<br>想一下，我们在函数中，故意设置LR返回地址，估计反编译器就无能为力了。针对这种情况，我们可以用动态模拟器来调试，百试百灵</p>
<h3 id="6_最后">6    最后</h3><p>反汇编的过程就像填字游戏，给你有限信息，然后补齐整个游戏，还是挺好玩的</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hacker/">Hacker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDA/">IDA</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Raspberry-Pi-programming-IO" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/Raspberry-Pi-programming-IO/" class="article-date">
  	<time datetime="2015-10-26T16:50:39.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/Raspberry-Pi-programming-IO/">树莓派底层编程-GPIO篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>本来是准备写一篇用python控制GPIO的例子，结果发现太简单了，还是深入一些吧，多深入底层</p>
<p>接下来，我会按照下面的顺序来介绍：<br>1）GPIO控制器地址映射<br>2）GPIO主要控制寄存器介绍<br>3）GPIO操作流程<br>4）用C语言控制GPIO<br>6）用python来控制GPIO</p>
<h3 id="1_概述">1    概述</h3><p>树莓派2B采用的CPU为BCM2836，外设部分和BCM2835完全一致，所以就可以参考BCM2835的<a href="https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">寄存器手册</a><br>但是，这个寄存器手册笔误有点多，建议配合着wiki的<a href="http://elinux.org/BCM2835_datasheet_errata">勘误手册</a>来看</p>
<p>CPU总共有54个IO，每个IO都可以复用，配置输入或者输出模式，单从GPIO部分来看，比较简单，无非是输入／输出，触法模式等，和一般的MCU没有太大差异</p>
<h3 id="2_地址映射">2    地址映射</h3><p>BCM2835将BUS的地址空间，通过MMU映射到线性寻址空间，如下所示<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GPIO/">GPIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树莓派/">树莓派</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/27/Raspberry-Pi-programming-IO/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Note-on-compile-libnfc-and-mfoc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/22/Note-on-compile-libnfc-and-mfoc/" class="article-date">
  	<time datetime="2015-10-22T01:57:23.000Z" itemprop="datePublished">2015-10-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/22/Note-on-compile-libnfc-and-mfoc/">Note on compile libnfc and mfoc</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="概述">概述</h4><p>本文主要记录编译nfc-tools时遇到的问题以及解决方案</p>
<p>测试平台：Raspberry 2B＋</p>
<h3 id="1-_访问不了google_code，无法下载源码">1.    访问不了google code，无法下载源码</h3><p>mfc-tools 仓库已经从google转移到<a href="https://github.com/nfc-tools" target="_blank" rel="external">github</a>上</p>
<h3 id="2-_编译nfcuk和mfoc时，autoreconf失败">2.    编译nfcuk和mfoc时，autoreconf失败</h3><p>加入<code>-vis</code>参数，全部指令如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoreconf -vis&#10;automake&#10;autoconf&#10;./configure&#10;make</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_按照网上教程，需要修改str_nfc_target函数">3.    按照网上教程，需要修改<code>str_nfc_target</code>函数</h3><p>不需要，现已修复</p>
<h3 id="4-_在树莓派2B＋上使用配置nfc，无法打开SPI端口，提示”TFI_error”">4.    在树莓派2B＋上使用配置nfc，无法打开SPI端口，提示”TFI error”</h3><p>修改SPI速率参数，保持默认值即可，<code>/etc/nfc/libnfc.conf</code>全文如下</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow device auto-detection (default: true)</span></span><br><span class="line"><span class="comment"># Note: if this auto-detection is disabled, user has to set manually a device</span></span><br><span class="line"><span class="comment"># configuration using file or environment variable</span></span><br><span class="line"><span class="constant">allow_autoscan</span> = true</span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow intrusive auto-detection (default: false)</span></span><br><span class="line"><span class="comment"># Warning: intrusive auto-detection can seriously disturb other devices</span></span><br><span class="line"><span class="comment"># This option is not recommended, user should prefer to add manually his device.</span></span><br><span class="line"><span class="constant">allow_intrusive_scan</span> = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set log level (default: error)</span></span><br><span class="line"><span class="comment"># Valid log levels are (in order of verbosity): 0 (none), 1 (error), 2 (info), 3 (debug)</span></span><br><span class="line"><span class="comment"># Note: if you compiled with --enable-debug option, the default log level is "debug"</span></span><br><span class="line"><span class="constant">log_level</span> = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manually set default device (no default)</span></span><br><span class="line"><span class="comment"># To set a default device, you must set both name and connstring for your device</span></span><br><span class="line"><span class="comment"># Note: if autoscan is enabled, default device will be the first device available in device list.</span></span><br><span class="line"><span class="comment"># 错误配置</span></span><br><span class="line"><span class="comment">#device.name = "Itead_PN532_SPI"</span></span><br><span class="line"><span class="comment">#device.connstring = "pn532_spi:/dev/spidev0.0:500000"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确配置</span></span><br><span class="line">device.name = "Itead_PN532_SPI"</span><br><span class="line">device.connstring = "pn532_spi:/dev/spidev0.0"</span><br></pre></td></tr></table></figure>
<h3 id="5-_PN532无法识别门禁卡">5.    PN532无法识别门禁卡</h3><p>可以识别13.56MHz 高频IC卡，但无法识别125KHz 低频ID卡<br>NOTE: 可以自制125KHz天线，软件模拟ID卡射频协议</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NFC/">NFC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PN532/">PN532</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RFID/">RFID</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-something-about-BCM2709-and-BCM2836" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/20/something-about-BCM2709-and-BCM2836/" class="article-date">
  	<time datetime="2015-10-20T07:42:58.000Z" itemprop="datePublished">2015-10-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/20/something-about-BCM2709-and-BCM2836/">something about BCM2709 and BCM2836</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><p>最近玩树莓派和编译内核的时候，经常发现树莓派官方和内核开发者对CPU的称呼有两种</p>
<ul>
<li>BCM2708/BCM2709</li>
<li>BCM2835/BCM2836</li>
</ul>
<p>内核开发者喜欢称之为BCM2708/9，而树莓派和博通则喜欢称为BCM2835/6</p>
<p>被搞的晕晕呼呼，所以花了几个小时找资料，看手册，弄清楚了二者的区别</p>
<h3 id="友情提醒">友情提醒</h3><p>本文部分链接，需要翻墙访问，请自备梯子</p>
<h3 id="二者区别">二者区别</h3><p>google了很多资料，发现</p>
<ul>
<li><strong>BCM2708/9 属于处理器的家族</strong></li>
<li><strong>BCM2835/6 属于处理的具体型号</strong></li>
</ul>
<p>树莓派内核开发者在github上有<a href="https://github.com/raspberrypi/linux/issues/22">相关讨论</a></p>
<p>摘录部分如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q: What&#39;s the correct device model to reference as the machine type and in any device drivers?&#10;&#10;A: Technically 2708 is the family, and 2835 is a specific implementation.&#10;   We now know that 2835 is the only implementation in the family that can run linux,&#10;   (and there won&#39;t be new models of this family), so it probably doesn&#39;t matter which model is used,&#10;   although it should be consistent.&#10;&#10;Q: So it would be reasonable to name all the drivers 2708 but the specific device tree file 2835?&#10;   (assuming that if there is ever another model of that family that can run linux it would need a&#10;&#9;different list of devices)&#10;A: That sounds reasonable.</span><br></pre></td></tr></table></figure>
<p>网上的更进一步讨论，请访问<a href="http://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835">why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835</a></p>
<p>另外，从<a href="https://en.wikipedia.org/wiki/VideoCore#Table_of_SoCs_adopting_VideoCore_SIP_blocks">wiki</a>得知，<br>博通联合树莓派已经完全开放BCM2835这颗CPU的资料，所以网上说的没有资料的情况，可以忽略</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The Broadcom YouTube page has videos demonstrating the video processing capability, but their website only goes as&#10;far as providing product briefs. Detailed data and development tools are only available under NDA, and then only for&#10;manufacturers with a market for very many units. However, on 28 February 2014, on the day of the second anniversary of&#10;the Raspberry PI Broadcom, together with the Raspberry PI foundation, announced the release of full documentation for&#10;the VideoCore IV graphics core, and a complete source release of the graphics stack under a 3-clause BSD license.</span><br></pre></td></tr></table></figure>
<p>树莓派BCM2835/6资料链接</p>
<ol>
<li><a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/README.md">https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/README.md</a></li>
<li><a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/README.md">https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/README.md</a></li>
</ol>
<p>对于博通BCM设计架构，他是将GPU作为MCU来使用，在启动时，加载bootloader，初始化RAM，外设等，然后启动ARM内核，开始全速运行状态<br>这样设计的好处是，ARM11或者ARM－A内核，完全作为运算核心；GPU处理视频和外设，系统可以无缝升级CPU，而对外设部分影响很小<br>就像这次的BCM升级到BCM2836，外设驱动，仅仅需要修改一下GPIO和DMA的偏移量，现有驱动代码，可以继续使用</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树莓派/">树莓派</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/20/something-about-BCM2709-and-BCM2836/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-hello-elua" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/19/hello-elua/" class="article-date">
  	<time datetime="2015-10-18T16:36:27.000Z" itemprop="datePublished">2015-10-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/19/hello-elua/">Hello elua</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述">概述</h3><p>下文会简单的介绍elua，然后编译固件，烧录到STM32F4 Nucleo板子上，最后用lua来编写一个简单的hello程序</p>
<h4 id="注意事项">注意事项</h4><p>在继续阅读之前，请看下面几点</p>
<ol>
<li>elua项目的版本比较多，代码文档和网站文档不一致，建议参考代码中的文档说明；本文档代码采用github master主分支0.9版本</li>
<li>本文以linux平台为例来说明编译过程，实际上，我是用树莓派来编译elua的，并用树莓派烧录，调试STM32；elua可以跨平台编译，具体请参考<a href="https://github.com/elua/elua/tree/master/doc/en">https://github.com/elua/elua/tree/master/doc/en</a>  building章节</li>
</ol>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elua/">elua</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lua/">lua</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/19/hello-elua/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-use-stm32F7-discovery-board" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/16/use-stm32F7-discovery-board/" class="article-date">
  	<time datetime="2015-10-16T15:04:31.000Z" itemprop="datePublished">2015-10-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/16/use-stm32F7-discovery-board/">STM32F7 Discovery 外部可用接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><p>拿到板子后，我们重点需要考虑的是STM32F7的板子还有多少资源可供我们使用<br>这里重点关注的是通信接口（比如SPI／I2C／IO之类的），因为可以通过这些接口外挂器件，拓展功能<br>查看F7手册和Discovery板子原理图，可以知道Discovery采用的是216Pin管脚的F746NG芯片，虽然板子外设比较多，<br>但芯片IO足够用</p>
<p>板子功能框架如下所示</p>
<p><img src="http://cedar-renjun.github.io/images/2015/10/16/1.png" alt="Discovery功能框图"></p>
<p>大致将IO分为以下几个部分</p>
<ol>
<li>USB OTG(HS/FS)</li>
<li>Camera</li>
<li>Audio</li>
<li>Ethernet
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STM32F7/">STM32F7</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/16/use-stm32F7-discovery-board/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-light-led-via-different-ways-in-rt-thread" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/15/light-led-via-different-ways-in-rt-thread/" class="article-date">
  	<time datetime="2015-10-15T15:27:20.000Z" itemprop="datePublished">2015-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/15/light-led-via-different-ways-in-rt-thread/">RT-Thread的小例子</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述">概述</h3><p>嵌入式中最简单的就是按键，点亮LED，很多入门教程中，将这个作为例子来讲解<br>下面我就用这个最简单的例子，来演示RT-Thread线程通讯组件的不同使用方法</p>
<ul>
<li>关中断</li>
<li>关调度器</li>
<li>信号量</li>
<li>互斥量</li>
<li>事件</li>
<li>邮箱</li>
<li>消息队列</li>
</ul>
<p>关于按键检测，为了简单，我用了轮询的模式，100ms轮询一次，然后检测电平是否有变，并做判断；<br>当检测到按键按下时，就翻转LED电平</p>
<p>最后，我们尝试用消息队列来实现：按下键后，LED闪烁多次</p>
<h3 id="测试环境">测试环境</h3><ol>
<li>RT-Thread stable 2.0.0</li>
<li>STM32F446RE Nucleo板子</li>
<li>IAR For ARM 7.4</li>
</ol>
<h3 id="准备工作">准备工作</h3><ol>
<li>搭建IAR开发环境，调整启动代码和链接脚本</li>
<li>修改gpio.c里面的<code>static const struct pin_index pins[]</code>数组，因为我们的F446RE Nucleo板子按键和LED分别接到<br>PC13和PA5上面，所以需要在pins表示里面包含这两个管脚，我这里显示的27和54，如下所示</li>
</ol>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/RT-Thread/">RT-Thread</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/10/15/light-led-via-different-ways-in-rt-thread/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Do one thing and do it well
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>