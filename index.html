<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Simple</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="技术的终极目标是简洁">
<meta property="og:type" content="website">
<meta property="og:title" content="Simple">
<meta property="og:url" content="cedar-renjun.github.io/index.html">
<meta property="og:site_name" content="Simple">
<meta property="og:description" content="技术的终极目标是简洁">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple">
<meta name="twitter:description" content="技术的终极目标是简洁">
  
    <link rel="alternative" href="/atom.xml" title="Simple" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Do one thing and do it well</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cedar-renjun" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1995742315/profile?topnav=1&wvr=6" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/BLE4-0/" style="font-size: 10px;">BLE4.0</a> <a href="/tags/CC26xx/" style="font-size: 10px;">CC26xx</a> <a href="/tags/Debugger/" style="font-size: 12.5px;">Debugger</a> <a href="/tags/ELF/" style="font-size: 17.5px;">ELF</a> <a href="/tags/GPIO/" style="font-size: 10px;">GPIO</a> <a href="/tags/Hacker/" style="font-size: 12.5px;">Hacker</a> <a href="/tags/IAR/" style="font-size: 10px;">IAR</a> <a href="/tags/IDA/" style="font-size: 12.5px;">IDA</a> <a href="/tags/Jlink/" style="font-size: 10px;">Jlink</a> <a href="/tags/M1/" style="font-size: 10px;">M1</a> <a href="/tags/NFC/" style="font-size: 12.5px;">NFC</a> <a href="/tags/PN532/" style="font-size: 10px;">PN532</a> <a href="/tags/RFID/" style="font-size: 10px;">RFID</a> <a href="/tags/STM32F7/" style="font-size: 10px;">STM32F7</a> <a href="/tags/TI/" style="font-size: 10px;">TI</a> <a href="/tags/USB/" style="font-size: 20px;">USB</a> <a href="/tags/elua/" style="font-size: 10px;">elua</a> <a href="/tags/lua/" style="font-size: 10px;">lua</a> <a href="/tags/sublime-text/" style="font-size: 10px;">sublime text</a> <a href="/tags/微信订阅号/" style="font-size: 15px;">微信订阅号</a> <a href="/tags/树莓派/" style="font-size: 12.5px;">树莓派</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.miaoxiong.net/">喵兄</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://ahnniu.github.io/">牛工</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Cedar, 嵌入式软件工程师，玩过各种MCU，熟悉无线协议栈，USB，RTOS，半个软件架构师，最近在折腾调试器. QQ: 819280802</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Do one thing and do it well</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Do one thing and do it well</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cedar-renjun" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1995742315/profile?topnav=1&wvr=6" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Day3-USB" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/09/Day3-USB/" class="article-date">
  	<time datetime="2015-12-09T13:00:21.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/Day3-USB/">Day4 USB的历史因素</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​<br>回顾一下，昨天的故事</p>
<blockquote>
<p>你到政府部分办事，首先需要找到办事窗口，然后告诉TA你是谁，能办什么事，来办什么事，然后把你的手机号，邮箱告诉TA    </p>
<p>接着，办事人员给你一个登记号，然后说，记下了，稍后我会派专员联系你</p>
<p>然后，你就回家了，等着电话，10分钟后，电话来了，对话如下</p>
<p>办事专员：我是XX号客服，你是不是YY，登记号是ZZ</p>
<p>你           ：是的<br>办事专员：巴拉巴拉<br>你           ：巴拉巴拉</p>
<p>最后，通话结束</p>
</blockquote>
<p>上面的事情，细化一下，完全可以套用到USB通讯过程</p>
<ol>
<li>你到政府部分办事，首先需要找到办事窗口（插入USB设备）</li>
<li>然后窗口接待人员问了你一些基本信息，姓名，性别（USB主机主动获取设备描述符）</li>
<li>帮你取了个号（设置USB设备地址），突然把你名字忘了，哎，那谁，XYZ号，你叫啥名儿？办什么事？你只好又重复一遍（USB主机主动获取设备描述符，配置描述符，接口描述符，端点描述符）</li>
<li>办事人员，最后问你家在哪，电话号码多少（USB主机记录接口描述符，端点描述符）</li>
<li>接着，TA说，好，记下了（注册USB设备到系统），稍后我会派专员联系你（匹配USB驱动），你可以回家了，保持电话畅通（等待端口事件）</li>
<li>然后，你就回家了，等着电话，10分钟后，电话来了（发生数据交互）<br>对话如下</li>
<li>办事专员：我是XX号客服，你是不是YY，登记号是ZZ（确定USB设备地址，端口地址）</li>
<li>你           ：是的<br>办事专员：巴拉巴拉<br>你           ：巴拉巴拉<br>（PC与USB设备发生数据交换）</li>
<li>最后，通话结束（结束通信）</li>
</ol>
<p>PS：上面的有一些术语，看不懂没关系，暂时忽略。重点关注整个交互流程</p>
<p>技术的产生和发展，都是跟当时社会的整体环境相适应的；这一点在IT技术上尤其明显</p>
<p>先了解USB 技术的历史背景，然后再想想USB解决了什么问题，就能理解USB架构为什么这样设计了</p>
<p>我一直认为：技术架构，从任何部分来看，都是很简单的<br>真正的困难在于，技术要求精确，所以会有大量细节性知识，精确描述性术语，把整体架构给掩盖住了</p>
<p>类似盲人摸象，这有俩洞，是啥玩意？？？摸了半天，发现是个鼻子，，，<br>再摸大象腿，最后耳朵，最后摸了一遍<br>然后在脑海里拼了半天，我擦，这玩意就是个大象</p>
<p>学技术也是类似的情况，先远观，掌握大致轮廓，然后慢慢细究，根本没有解决不了的技术问题</p>
<p>OK，回到USB的历史</p>
<p>几年前，电脑上有RJ45网口，DB9串口，视频输出口，打印机并口，还有光盘啥的，反正电脑上有各种形状的接口</p>
<p>后来消费者一看，妈蛋，这玩意不行啊，包里一堆线，不好插，体积也大，要搞死了<br>PC大厂一看，擦，这是个机会啊，我先推出小接口的电脑，就能搞死对手</p>
<p>然后，问题就来了</p>
<ol>
<li>微软说了，你们随便搞，反正我要原来的电脑软件还要能用，驱动还能用，不然搞死你们</li>
<li>消费者说了，电脑上别有各种形状的接口，要简单，要速度快，不然买别家电脑去</li>
<li>工厂说了，线材制作要简单，线越少越好，不要良品率低，自己看着办</li>
</ol>
<p>一帮IT大神，微微一笑，小case</p>
<blockquote>
<p>硬件不够，软件来凑</p>
</blockquote>
<p>然后就把这个问题轻轻松松搞定了</p>
<p>怎么解决的？明天继续</p>
<h3 id="每日推荐">每日推荐</h3><blockquote>
<p>任何计算机问题，都能通过增加一个层来解决</p>
</blockquote>
<p>CSAPP上看的，忘了谁说的了，反正是个牛逼的人物</p>
<p><a href="http://www.amazon.cn/Computer-Systems-A-Programmer-s-Perspective-Bryant-Randal-E/dp/0136108040/ref=sr_1_5?s=books&amp;ie=UTF8&amp;qid=1449665814&amp;sr=1-5&amp;keywords=Computer+Systems%3A+A+Programmer%27s+Perspective" target="_blank" rel="external">CSAPP - Computer Systems: A Programmer Perspective </a></p>
<p>这是本神书，1300多页，CSAPP的介绍请百度或者google，据说看完的都成为大神了</p>
<p>国内有俩研究生，看完这本书的某几个章节，然后写了一本书《程序员的自我修养－编译，链接，库》</p>
<p>哦，我现在还没看完，，，</p>
<p>英文原版（299元）非常通俗易懂，千万不要买中译本，翻译的太垃圾，，，</p>
<p>2015-12-9</p>
<p>－－－－－分割线－－－－－<br><strong>注意事项</strong></p>
<ol>
<li><p>本订阅号（微信搜 McuProgramming ）主要发布一些嵌入式相关的知识和技巧，涉及到软件，硬件，射频，协议栈等；如果您有感兴趣的领域，请通过回复订阅号告诉我</p>
</li>
<li><p>本订阅号主要是简单文字为主，内含少量代码段，但绝不会发布大量的代码。<br>因为根据自己的体会，在手机微信端看代码的体验非常糟糕，一方面屏幕比较小，显示效果不好；另一方面，玩手机时，精力不会集中，更不会有大量时间。<br>cedar-renjun.github.io 个人博客会发一些技术细节的东西，感兴趣的，可以深入研究这里的博文</p>
</li>
<li><p>微信的编辑功能比较弱，不能贴链接，代码啥的，，，所有文章均发表在个人博客，可以通过点击原文来查看，原文有代码语法高亮，显示图片，带链接等效果</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信订阅号/">微信订阅号</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Day-3-USB" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/08/Day-3-USB/" class="article-date">
  	<time datetime="2015-12-08T15:04:52.000Z" itemprop="datePublished">2015-12-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/08/Day-3-USB/">USB的通俗解释</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​</p>
<h2 id="Day_3_USB架构的通俗解释">Day 3 USB架构的通俗解释</h2><p>做个小游戏，仔细回想一下两年前做的项目，看能否记得所有细节</p>
<p>估计90%的人只记得功能性层面的东西，比如项目是干嘛的，解决什么问题的，至于编程语言层面的细节，早已经忘的一干二净</p>
<p>所以，我不会一上来就给你一大堆各种专业术语，然后陷入USB技术细节<br>这么做的结果是，你听不懂，也记不牢，半个月后，脑袋里面，一片空白，毛都不剩</p>
<p>我们学习一个新事物，只有先有感性认识，有了大致轮廓，然后类比其它事物，比较之后，才会在大脑中建立起系统整体架构</p>
<p>这是由大脑的运行机制来决定的，大脑不会记忆太多细节，越高层，处理的越事情越抽象</p>
<p>公司也是同样的机制，高层管理者只关心企业战略，不会考虑程序员的代码风格是否规范，合理</p>
<p>ok，先看下面一则小故事</p>
<p>很简单，还记得上篇的提示么，多想想现实社会的办事流程</p>
<p>你到政府部分办事，首先需要找到办事窗口，然后告诉TA你是谁，能办什么事，来办什么事，然后把你的手机号，邮箱告诉TA</p>
<p>接着，办事人员给你一个登记号，然后说，记下了，稍后我会派专员联系你</p>
<p>然后，你就回家了，等着电话，10分钟后，电话来了，对话如下</p>
<p>办事专员：我是XX号客服，你是不是YY，登记号是ZZ<br>你           ：是的<br>办事专员：巴拉巴拉<br>你           ：巴拉巴拉</p>
<p>最后，通话结束</p>
<p>思考几个问题：</p>
<ol>
<li>政府为什么要设立统一的接待入口？</li>
<li>办事人员怎么联系你？</li>
<li>如果这时来了另外一个人来办事，政府需不需要另外增加一个办事窗口？</li>
</ol>
<p>OK，咱们明天继续</p>
<h3 id="每日推荐">每日推荐</h3><ol>
<li><a href="http://www.amazon.cn/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%80%9A%E4%BF%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-%E6%96%AF%E7%91%9E%E5%BE%B7%E5%93%88/dp/B0011APWUQ/ref=sr_1_9?s=books&amp;ie=UTF8&amp;qid=1449584809&amp;sr=1-9&amp;keywords=%E5%B5%8C%E5%85%A5%E5%BC%8F+%E9%80%9A%E4%BF%A1" target="_blank" rel="external">嵌入式通信软件设计</a><br>斯瑞德哈(T.Sridhar) 写的，协议栈的核心就是状态机，更大的说，计算机的核心就是状态机，想要深入研究协议栈实现机制的同学，可以买一本这书翻翻，很薄的一本书，干货儿不少。建议这本书配合着USB协议栈源码或者LwIP源码一起看</li>
</ol>
<p>PS：买计算机书籍，记得选这种红皮的，或者这种<a href="http://www.amazon.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%9B%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%B8%83%E8%8E%B1%E6%81%A9%E7%89%B9/dp/B004BJ18KM/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1449586593&amp;sr=1-1&amp;keywords=CSAPP" target="_blank" rel="external">CSAPP</a>黑皮的</p>
<p>2015-12-8</p>
<p>－－－－－分割线－－－－－<br><strong>注意事项</strong></p>
<ol>
<li><p>本订阅号主要发布一些嵌入式相关的知识和技巧，涉及到软件，硬件，射频，协议栈等；如果您有感兴趣的领域，请通过回复订阅号告诉我</p>
</li>
<li><p>本订阅号主要是简单文字为主，内含少量代码段，但绝不会发布大量的代码。<br>因为根据自己的体会，在手机微信端看代码的体验非常糟糕，一方面屏幕比较小，显示效果不好；另一方面，玩手机时，精力不会集中，更不会有大量时间。<br>cedar-renjun.github.io 个人博客会发一些技术细节的东西，感兴趣的，可以深入研究这里的博文</p>
</li>
<li><p>所有文章发表在个人博客，可以通过点击原文来查看，原文有代码语法高亮，显示图片，带链接等效果</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信订阅号/">微信订阅号</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-usb-reference-docunment" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/07/usb-reference-docunment/" class="article-date">
  	<time datetime="2015-12-07T13:54:27.000Z" itemprop="datePublished">2015-12-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/07/usb-reference-docunment/">USB 参考资料</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>注意</strong></p>
<ol>
<li><p>本订阅号主要发布一些嵌入式相关的知识和技巧，涉及到软件，硬件，射频，协议栈等；如果您有感兴趣的领域，请通过回复订阅号告诉我</p>
</li>
<li><p>本订阅号主要是简单文字为主，内含少量代码段，但绝不会发布大量的代码。<br>因为根据自己的体会，在手机微信端看代码的体验非常糟糕，一方面屏幕比较小，显示效果不好；另一方面，玩手机时，精力不会集中，更不会有大量时间。<br>cedar-renjun.github.io 个人博客会发一些技术细节的东西，感兴趣的，可以深入研究这里的博文</p>
</li>
</ol>
<h3 id="0x00_一点废话">0x00 一点废话</h3><p>在列USB参考资料之前，先聊一点废话</p>
<p>从09年大二时，就买了一本《USB应用程序开发》，很不幸，当时没看懂，对我来讲，完全是天书，各种传输层次，太复杂了，脑容量不够，于是就放下了，现在那本书还在书柜里躺着，罪过，罪过</p>
<p>后面一直折腾单片机，从51，到AVR，到STM32，到TI的LM3S9B96，飞思卡尔的KL系列，东芝的片子，接触了很多MCU</p>
<p>越来越有种感觉：天下大同</p>
<p>计算机，公司，管理理论，行业，社会，自然界，表面是不相干的领域，但深入一层，发现背后的机理，完全相同</p>
<p>嵌入式是人来开发的，人离不开社会，所以社会的层次和架构，甚至哲学思想，会同样映射到嵌入式系统中，构建一个虚拟的数字社会</p>
<p>对此，推荐一本书《计算机的心智(操作系统之哲学原理)》，这本书对整个架构，社会映射机制解释的很好，可以说是彻底改变了我的计算机思想层次</p>
<pre><code>有时候，遇到解决不了，想不通的计算机问题，不妨观察一下现实社会，人是怎么解决类似问题的
</code></pre><p>请记住上面的话</p>
<h3 id="0x01_USB相关资料">0x01 USB相关资料</h3><p>学习USB过程中，看了不少资料，在此列出来，希望能帮到各位</p>
<ol>
<li><a href="www.usb.org">USB2.0协议</a><br>在学习USB前，请先翻翻USB原版协议，不要求能看懂，先了解框架，有个大致印象就好。回头再深入研究细节</li>
<li><a href="http://www.beyondlogic.org/usbnutshell/usb1.shtml" target="_blank" rel="external">USB in a NutShel</a><br>用非常通俗易懂的语言来教你怎么看USB协议，描述了整个架构，非常清晰</li>
<li><a href="http://bbs.ednchina.com/BLOG_computer00_27799.HTM" target="_blank" rel="external">电脑圈圈</a><br>我主要看上面两个资料，电脑圈圈的，据说不错，在此推荐一下</li>
<li>STM32 手册 USB章节<br>详细的读几遍</li>
<li>ST USB Device代码<br> 个人建议直接看源码，也不多，架构挺简单；不要被网上一大堆分析源码的文章迷惑，，，那是他们的事后总结，如果你希望通过看那些文章入门，注定是半吊子工程师，洗洗睡吧</li>
</ol>
<p>暂时就列这么多，学USB基础架构足够了，明天聊USB协议框架</p>
<p>PS：还记得那句话么<br><strong>有时候，遇到解决不了，想不通的计算机问题，不妨观察一下现实社会，人是怎么解决类似问题的</strong></p>
<p>USB就是为了简化设备接口而设计的，学架构时，搞不懂时，就多想想公司架构是怎么设计的，国家部门是怎么设计的</p>
<p>2015-12-7</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信订阅号/">微信订阅号</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-USB-update-firmware-for-stm32" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/03/USB-update-firmware-for-stm32/" class="article-date">
  	<time datetime="2015-12-03T12:43:47.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/03/USB-update-firmware-for-stm32/">USB 固件升级</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近做了一个USB工具，像U盘拷贝一样，升级STM32固件</p>
<p>手册链接如下所示</p>
<p>有朋友说amobbs下载不了文件，这里传一份吧</p>
<p><a href="https://github.com/cedar-renjun/cedar-renjun.github.io/tree/master/assets/2015/12/3/USB_MSD_Bootloader.hex.zip" target="_blank" rel="external">https://github.com/cedar-renjun/cedar-renjun.github.io/tree/master/assets/2015/12/3/USB_MSD_Bootloader.hex.zip</a><br><a href="https://github.com/cedar-renjun/cedar-renjun.github.io/tree/master/assets/2015/12/3/USB_MSD_Updater_User_Manual.pdf" target="_blank" rel="external">https://github.com/cedar-renjun/cedar-renjun.github.io/tree/master/assets/2015/12/3/USB_MSD_Updater_User_Manual.pdf</a><br><a href="https://github.com/cedar-renjun/cedar-renjun.github.io/tree/master/assets/2015/12/3/USB_MSD_Bootloader_Usage.pdf" target="_blank" rel="external">https://github.com/cedar-renjun/cedar-renjun.github.io/tree/master/assets/2015/12/3/USB_MSD_Bootloader_Usage.pdf</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-usb-re-enum" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/28/usb-re-enum/" class="article-date">
  	<time datetime="2015-11-28T11:41:57.000Z" itemprop="datePublished">2015-11-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/28/usb-re-enum/">USB 重枚举</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基本思路：拉低DP信号，保持一定时间，然后释放</p>
<p>在STM32上的用法为：</p>
<ol>
<li>关闭USB电源</li>
<li>配置DP脚，拉低</li>
<li>延时一段时间，释放DP脚</li>
<li>重新配置USB</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-usb-suspended" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/25/usb-suspended/" class="article-date">
  	<time datetime="2015-11-25T14:35:29.000Z" itemprop="datePublished">2015-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/25/usb-suspended/">usb suspended</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Q: USB设备进入暂停模式的条件是？<br>A: 总线上，3ms空闲状态，即让设备进入暂停模式</p>
<p>Q: USB设备如何退出暂停模式？<br>A: USB任意的总线活动，都会让USB设备退出休眠状态，但一般情况来说，虽然USB<br>Device会产生唤醒中断，但软件层面硬件检查DP，DM的电平值，从而确定是干扰还是HOST唤醒事件</p>
<p>Q: 退出暂停模式后，需要重新进行配置么？<br>A: 不需要，因为在暂停时，已经保存了内部状态，比如端点信息和地址信息；在恢复时，只需要恢复时钟和对应外设功能就好</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-usb-recognition-produce" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/22/usb-recognition-produce/" class="article-date">
  	<time datetime="2015-11-21T16:33:55.000Z" itemprop="datePublished">2015-11-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/22/usb-recognition-produce/">USB 插入动作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>USB 设备插入</li>
<li>HUB 通过检测DP/DM电平变化，识别出USB插入动作</li>
<li>HUB 等待100ms左右，等待设备供电稳定和初始化完成</li>
<li>HUB 请求 Device复位，Device进入默认状态，此时最大可用电流为100ma</li>
<li>HUB 分配唯一地址给Device</li>
<li>HUB 发送设备请求命令，获取Device属性和功能</li>
<li>HUB 根据实际情况，返回配置信息，配置Device，Device完成配置</li>
<li>Device处于可用状态，开始正常传输数据</li>
<li>Device设备拔出，HUB回收地址，更新逻辑树结构，通知HOST</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-why-use-required-device-reset-when-plugin" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/22/why-use-required-device-reset-when-plugin/" class="article-date">
  	<time datetime="2015-11-21T16:07:10.000Z" itemprop="datePublished">2015-11-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/22/why-use-required-device-reset-when-plugin/">为什么USB协议中，检测到设备插入时，要求复位</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为USB属于可插拔设备，这种特性就要求设备不具备记忆的特性，也就是有限状态机特性。<br>为了确保状态可控，所以就要求设备复位，从而</p>
<ol>
<li>确保HUB检测到设备拔出时，能及时回收地址</li>
<li>确保USB设备在插入HUB端口时，能进入一个确定的状态，消除旧环境的影响</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/USB/">USB</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-kill-your-self-in-CC25xx-CC24xx-SOC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/08/kill-your-self-in-CC25xx-CC24xx-SOC/" class="article-date">
  	<time datetime="2015-11-07T16:58:35.000Z" itemprop="datePublished">2015-11-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/08/kill-your-self-in-CC25xx-CC24xx-SOC/">编写自杀式代码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>在制作TI调试器时，需要在RAM中执行代码，并擦除原有固件，然后接收调试器发来的数据文件，写入FLASH中，从而完成系统烧写和调试功能</p>
<p>该技术可以用作自杀式入侵代码，完成工作后，清除所有代码信息，然后重启<br>已经测试通过，并十分有效，简单的说一下基本思路，详细信息不便透露</p>
<h3 id="1_基本步骤">1    基本步骤</h3><ol>
<li>调试器连接MCU</li>
<li>更新固件</li>
<li>完成系统初始化和C－Runtime初始化</li>
<li>映射RAM执行缓冲区，设置断点</li>
<li>执行RAM函数，使用DMA擦除固件信息，准备接收调试器发送的数据资料</li>
</ol>
<h3 id="2_特别说明">2    特别说明</h3><ol>
<li>我已经在用STM32来调试CC25xx/CC23xx系列芯片，同时具备烧写功能</li>
<li>该技术可以和缓冲区漏洞结合起来，得到系统固件，并擦除自身，完全不留任何作案信息</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Debugger/">Debugger</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Learn-CC26xx-with-me-lesson-00" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/05/Learn-CC26xx-with-me-lesson-00/" class="article-date">
  	<time datetime="2015-11-04T17:37:05.000Z" itemprop="datePublished">2015-11-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/05/Learn-CC26xx-with-me-lesson-00/">跟我学蓝牙4.0之－CC26xx系列教程－00</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_认识TI_SimpleLink_系列">0    认识TI SimpleLink 系列</h3><p>TI的无线产品线非常丰富，从低频RFID/NFC，到Sub－1G系列，再到BLE4.0，Zigbee，Wi-Fi等各种芯片，应有尽有，足以满足您苛刻的应用场景。<br>可以细分为以下几个系列</p>
<ol>
<li>RF430<br>13.56MHz NFC/RFID SOC 解决方案</li>
<li>CC430<br>Sub-1G 工业无线网络解决方案</li>
<li>SimpleLink CC1x<br>最新一代的Sub－1G SOC 解决方案，采用最新RF内核，功耗更低，性能更加强劲</li>
<li>SimpleLink CC2x<br>新一代2.4G 解决方案，可用于BLE4.0，Zigbee协议栈</li>
<li>SimpleLink CC3x<br>Wi-Fi SOC解决方案，双核架构，内置TCP／IP协议栈，性能最高，已通过FCC, IC, CE and TELEC认证</li>
</ol>
<p>随着物联网的到来，SOC无线芯片已经是一个趋势，但射频开发中，还是会出现很多问题：</p>
<ol>
<li>天线设计门槛很高，需要精通射频知识</li>
<li>无线协议栈学习成本过高</li>
<li>多种软件协议标准，应用层软件不兼容</li>
</ol>
<p>针对上面的问题，TI推出<code>SimpleLink</code>系列无线芯片，在软件层面上兼容现有的无线协议，从而达到学会一种CC系列芯片，掌握全系列的无线的效果；<br>同时，TI提供很多天线参考设计，完完全全的交钥匙(Turn-Key)方案，用户可以直接使用这些参考设计，从而加速产品上市</p>
<h3 id="1_认识TI_CC26xx系列">1    认识TI CC26xx系列</h3><p>我们的重点是来学习TI CC26xx 2.4G无线蓝牙4.0产品系列，TI将CC2x系列细分为以下三种</p>
<ol>
<li>CC2630系列<br>802.15.4 MESH解决方案，用于实现Zigbee或者6LoWPAN MESH网络</li>
<li>CC2640系列<br>2.4G 蓝牙4.1系列芯片</li>
<li>CC2650系列<br>全能芯片，兼容CC2630/CC2640，能实现蓝牙4.0／Zigbee／6LoWPAN协议，从而实现一个芯片多种协议</li>
</ol>
<h3 id="2_开发环境和开发工具">2    开发环境和开发工具</h3><p>TI CC26xx支持很多IDE开发工具，具体包括：</p>
<ol>
<li>IAR</li>
<li>CCS</li>
<li>MDK</li>
<li>GCC</li>
<li>BLE Studuio</li>
</ol>
<p>更多工具信息，请参考<a href="http://processors.wiki.ti.com/index.php/CC13xx_CC26xx_Tools_Overview" target="_blank" rel="external">wiki－开发工具页面</a></p>
<p>这么多工具，我们学习CC26xx时，该怎么选呢？<br>我们推荐</p>
<ol>
<li>IAR 7.4</li>
<li>XDS110</li>
</ol>
<p>因为TI官方协议栈，都是用IAR来管理工程的，所以安装IAR能为我们的学习避免很多潜在的问题<br>另外，XDS110的调试速度很快，不会像某些Jlink一样，总是丢失固件</p>
<p>总之一句话：我们是学习蓝牙4.0的，要选择稳定的工具，不要把精力浪费在调试工具上</p>
<p>下一篇，我们将介绍怎么安装IAR和TI蓝牙4.0协议栈</p>
<h3 id="3_参考资料">3    参考资料</h3><ol>
<li><a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/wireless_mcus/overview.page" target="_blank" rel="external">TI SimpleLink</a></li>
<li><a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/wireless_mcus/simplelink_cc1x/overview.page" target="_blank" rel="external">CC1x 系列</a></li>
<li><a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/wireless_mcus/simplelink_cc2x/overview.page" target="_blank" rel="external">CC2x 系列</a></li>
<li><a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/wireless_mcus/simplelink_cc3x/overview.page" target="_blank" rel="external">CC3x 系列</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BLE4-0/">BLE4.0</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CC26xx/">CC26xx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TI/">TI</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-parallel-technology-in-programmer" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/05/parallel-technology-in-programmer/" class="article-date">
  	<time datetime="2015-11-04T16:53:35.000Z" itemprop="datePublished">2015-11-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/05/parallel-technology-in-programmer/">烧录器中的并行技术</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>利用RTOS的并行技术，我们能充分的发挥宿主MCU的性能，从而最大程度的提高程序烧写速度</p>
<h3 id="1_理论基础">1    理论基础</h3><ol>
<li>烧写器的烧写速度瓶颈不在于传输速率</li>
<li>CPU在DMA烧写FLASH的同时，可以在RAM中同时接收数据</li>
<li>一个FLASH控制器，只允许一个DMA操作</li>
</ol>
<h3 id="2_基本思路">2    基本思路</h3><ol>
<li>采用RAM FIFO机制，假设为A，B Block</li>
<li>先填充A，然后启动DMA，开始烧录扇区1</li>
<li>填充B，等待扇区1烧录完毕，配置DMA，烧录扇区2</li>
<li>填充A，等待扇区2烧录完毕，然后配置DMA</li>
<li>重复3.4步骤，直到完成</li>
</ol>
<h3 id="3_注意事项">3    注意事项</h3><ol>
<li>可以根据DMA的速率和系统总线速率，调整Block的大小和数据，从而尽可能的让DMA接近全负荷运行，从而达到理论FLASH理论烧写速率</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Debugger/">Debugger</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-elf-format-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/02/elf-format-3/" class="article-date">
  	<time datetime="2015-11-02T10:21:08.000Z" itemprop="datePublished">2015-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/02/elf-format-3/">ELF文件分析之3 － 动态链接</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述">概述</h3><p>相对于静态链接，动态链接和加载机制更加复杂，但对于系统来说，动态加载能更节省内存和其它计算资源</p>
<p>这里面涉及到的主要技术点为：</p>
<ol>
<li>GOT表</li>
<li>PLT表</li>
<li>延迟绑定</li>
</ol>
<p>基本过程为</p>
<ol>
<li>调用系统加载程序</li>
<li>调用程序所需要的动态库，并分配程序段地址</li>
<li>进行初始化，构建运行时环境（Run Time)</li>
<li>运行程序，第一次遇到动态未定义符号时，调用动态解析函数，找到符号地址，将信息写入绑定表</li>
<li>第二次调用符号时，直接进入查找表，调用对应函数</li>
</ol>
<p>所以，下面，分别介绍GOT和PLT，然后用实例来分析函数符号动态加载机制</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/">ELF</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/11/02/elf-format-3/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-elf-format-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/02/elf-format-2/" class="article-date">
  	<time datetime="2015-11-02T07:09:22.000Z" itemprop="datePublished">2015-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/02/elf-format-2/">ELF文件分析之2 － 静态链接</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_概述">0    概述</h3><p>有了上面两篇文章的铺垫，再看一遍ELF1.1规范，就已经简单的入门了<br>这篇文章，主要讲静态链接中的符号重定向过程和ELF处理机制</p>
<h3 id="2_变量内存分布">2    变量内存分布</h3><p>我们知道，C语言的变量按作用域来分，包括：</p>
<ol>
<li>全局作用域变量<br>未加static修饰的变量，这种变量会标记为PUBLIC，并对外可见</li>
<li>文件作用域变量<br>static修饰的变量，这种变量会标记为LOCAK，对外不可见</li>
<li>局部作用域变量<br>block里面的变量<br>什么是block呢，就是包含在<code>{}</code>里面的，未被static修饰的变量，这种变量会放在栈中，没有任何标记，对外不可见</li>
</ol>
<p>也许你会问，C语言中有很多类型的变量，比如int，char，enum等，你为什么只提变量，而不提具体类型？<br>这是因为，变量类型仅仅对高级语言有效，机器码里面并没有数据类型，CPU只认识特定宽度的数据，然后做基本运算。<br>真的，在ELF里面，只有<code>OBJECT</code>,<code>FUNC</code>两种类型符号，我们来尝试一下</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/">ELF</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/11/02/elf-format-2/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-elf-format-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/01/elf-format-1/" class="article-date">
  	<time datetime="2015-11-01T15:13:07.000Z" itemprop="datePublished">2015-11-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/01/elf-format-1/">ELF文件分析之1 － 文件格式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>上一篇，我们知道了ELF文件是什么，以及怎么用，本篇重点介绍ELF的文档规范</p>
<h3 id="1_整体结构">1    整体结构</h3><p>ELF适用于3种文件结构</p>
<ol>
<li>重定向文件<br>也就是经常见到的<code>.o</code>文件，用于保存代码和数据，链接器用使用这个文件来创建<code>可执行文件</code>或者<code>共享文件</code></li>
<li>可执行文件<br>也就是linux下面的<code>.out</code>文件，用于执行</li>
<li>共享文件<br>常见的静态库<code>.lib</code>或者动态库<code>.so</code>，就是这个文件格式，就是由多个<code>.o</code>压缩成的，可以用于保存代码或者数据，节省编译时间</li>
</ol>
<p>上面三种文件，再综合一下，可以分为两种</p>
<ol>
<li>链接文件（中间态）</li>
<li>可执行文件（最终态）</li>
</ol>
<p>ELF分别用两种视图来表示二者，如下所示<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/">ELF</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/11/01/elf-format-1/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-elf-format-0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/31/elf-format-0/" class="article-date">
  	<time datetime="2015-10-31T15:11:22.000Z" itemprop="datePublished">2015-10-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/31/elf-format-0/">ELF文件分析之0 － 简介和分析工具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>几年前，在读大学时，刚接触linux的时候，就对计算机的运行原理比较感兴趣，网上找了《CSAPP》和《程序员的自我修养－链接，库》，无奈当时能力不足，<br>看不懂这些，后面工作了，一直从事嵌入式偏底层的工作，比较熟悉gcc和linker，刚好最近研究hacker和工程需要，就耐着性子研究了ELF文件结构，遇到问题<br>不少，最终也解决了，所以写到blog记录一下，免得忘记</p>
<h3 id="1_概述">1    概述</h3><p>因为ELF涉及的东西比较多，所以分为4篇来介绍</p>
<ol>
<li>ELF简介和分析工具<br>主要介绍ELF的基本知识和讲解ELF分析工具的基本用法</li>
<li>ELF文件格式分析<br>主要介绍ELF文件格式</li>
<li>ELF静态链接<br>主要分析静态链接中需要解决的问题，以及基本原理</li>
<li>ELF动态链接<br>主要分析动态链接中需要解决的问题，以及基本原理</li>
</ol>
<p>OK, 进入正题<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ELF/">ELF</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/31/elf-format-0/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-something-about-crack-m1-card" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/something-about-crack-m1-card/" class="article-date">
  	<time datetime="2015-10-27T15:08:40.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/something-about-crack-m1-card/">破解M1卡</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_概述">0    概述</h3><p>本文主要介绍破解M1卡所需要的工具和基本思路和注意事项，不会讲述详细的步骤<br>如果对此有兴趣，想深入研究，请搜索关键词<code>nfc-tools</code>, <code>libnfc</code>, <code>mfoc</code></p>
<h3 id="1_基本思路">1    基本思路</h3><ol>
<li>尝试默认密码</li>
<li>尝试常用密码</li>
<li>逐个扇区的尝试，发现某个扇区内有默认密码，则可以根据M1加密算法漏洞来分析出其它扇区的密码</li>
<li>如果扇区没有默认密码，则软件破解失败；可以尝试用软件无线电来监听通讯过程，分析密码或者重放攻击</li>
</ol>
<h3 id="2_工具">2    工具</h3><ol>
<li>PN532或者ACR322</li>
<li><a href="http://www.hackrf.net/" target="_blank" rel="external">HackRF</a></li>
<li>libnfc和mfoc</li>
<li>树莓派或者类似的linux系统<a href="https://www.kali.org/news/kali-linux-software-defined-radio-support/" target="_blank" rel="external">kali</a></li>
</ol>
<h3 id="3_其它">3    其它</h3><ol>
<li><p>能破解公交卡么<br>我尝试了下，无法破解，全部扇区加密，估计也有服务器验证机制<br>回头尝试暴力破解试试</p>
</li>
<li><p>SDR是什么<br>经常有人问SDR是什么，这里解释下：SDR全称Software Defined Radio, 表示软件无线电，可以用软件＋FPGA来模拟10M-6GHz的射频信号， 从而用软件协议来实现硬件射频芯片功能</p>
</li>
</ol>
<p>常用的软件无线电工具有</p>
<ol>
<li><a href="http://www.rtl-sdr.com/" target="_blank" rel="external">http://www.rtl-sdr.com/</a></li>
<li><a href="http://www.hackrf.net/" target="_blank" rel="external">http://www.hackrf.net/</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M1/">M1</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NFC/">NFC</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-IDA-Pro-Reading-note-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/IDA-Pro-Reading-note-1/" class="article-date">
  	<time datetime="2015-10-27T14:38:33.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/IDA-Pro-Reading-note-1/">IDA Pro学习笔记－1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_概述">0 概述</h3><p>本文主要介绍常用的，简单的逆向和反汇编工具</p>
<h3 id="1_分类工具">1    分类工具</h3><p>在遇到一个新文件时，我们需要知道，这是一个什么类型的文件；记得，看后缀名来判断是不准确的，下面的几个工具，用来帮助你检验文件类型</p>
<ol>
<li><p>file<br>Linux下面的命令行工具，可以利用后缀名，文件头的特征码，文件开头的特殊命令行来判断类型，能识别绝大多数的文件类型</p>
</li>
<li><p>PE Tools<br>一组用于分析windows系统中正在运行的进程和可执行文件的工具。能捕获进程，并将内存映像转储，然后用PE<br>sniffer来分析可执行文件是由何种编译器构建的</p>
</li>
<li><p>PEiD<br>windows工具，用于识别构建EXE文件所有的编译器，并确定混淆代码的工具类型</p>
</li>
</ol>
<h3 id="2_摘要工具">2    摘要工具</h3><p>在分析到类型后，我们就需要分析文件内的详细信息，下面这些工具就该派上用场了</p>
<ol>
<li><p>nm<br>显示出目标文件中的所有符号；我们知道，obj文件里面都有很多符号段，用于存储符号信息，nm就可以将这些信息给打印出来，便于分析</p>
</li>
<li><p>ldd<br>用于解析静态链接或者动态链接的库信息</p>
</li>
<li><p>objdump<br>大而全的工具，用于显示目标文件的所有信息，比如节头部，专用头部，调试信息，符号信息，反汇编代码等<br>还有一个readelf工具，也有同样的功能；<br>二者的区别是：objdump依赖于libbfd，readelf不依赖libbfd</p>
</li>
<li><p>otool<br>mac OS X底下的objdump工具</p>
</li>
<li><p>dumpbin<br>VS套件里面的一个工具，功能类似objdump和ldd</p>
</li>
<li><p>C++filt<br>C＋＋会将重载函数进行重命名（name－mangling），从而保证符号唯一性，但这样为我们理解反编译函数名称造成了困难，filt就是复原原始函数名用的<br>，比如<code>nm a.out | grep demo | c++filt</code>就可以复原a.out里面所有的demo函数名</p>
</li>
</ol>
<h3 id="3_深度监测工具">3    深度监测工具</h3><ol>
<li><p>strings<br>用于提取文件中的字符串内容，我们经常在windows里面可以看到提示性文字，通过这个工具，我们就知道文字的位置，然后反向找出调用文字的程序<br>代码，最后修改代码即可<br>但是记住，不要用文字信息来推断程序功能</p>
</li>
<li><p>反汇编器<br>X86架构下的ndisasm和diStorm可以用来反汇编代码和数据</p>
</li>
</ol>
<h3 id="4_最后">4    最后</h3><p>这些工具很基础，都是linux下的常用工具，应该掌握</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hacker/">Hacker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDA/">IDA</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-IDA-Pro-Reading-note-0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/IDA-Pro-Reading-note-0/" class="article-date">
  	<time datetime="2015-10-27T03:48:20.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/IDA-Pro-Reading-note-0/">IDA Pro学习笔记－0</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_概述">0    概述</h3><p><a href="https://www.hex-rays.com/index.shtml" target="_blank" rel="external">IDA</a>，懂的人自然懂，不懂的人请百度<br>这里不做过多介绍</p>
<p>本篇作为学习笔记的第一篇，主要介绍反汇编的理论和常见反汇编方式</p>
<h3 id="1_反汇编简介">1    反汇编简介</h3><p>编程语言进化过程为：二进制－》汇编－》C／C++等编译语言－》python等动态脚本语言<br>二进制的，可以直接看ARM Thumb2指令集手册，里面有对应的编码介绍，汇编就是ARM中常见的启动代码，<br>C／python之类的，都是程序员常见的语言，都很熟悉，不多介绍</p>
<h3 id="2_为什么要反汇编">2    为什么要反汇编</h3><p>反汇编的意义在于，很多时候，我们并不能拿到C级别的源码，只能拿到bin格式的固件，所以需要通过bin来反向成汇编代码，然后分析程序<br>其它的几个原因</p>
<ol>
<li>分析恶意软件</li>
<li>分析闭源软件的漏洞</li>
<li>分析闭源软件的互操作性</li>
<li>分析编译器生成代码，以验证编译器性能和准确性</li>
<li>在调试时显示程序指令</li>
</ol>
<h3 id="3_反汇编的困难">3    反汇编的困难</h3><p>理论上来讲，bin属于透明代码，大神可以直接看二进制格式，但这么做效率太低，所以很多人做了工具，IDA就是其中一种，虽然有了工具，<br>但分析过程，仍然困难重重，原因如下</p>
<ol>
<li>编译过程会造成损失<br>bin是给机器看的，所以它不需要任何变量或者函数，但我们需要，所以变量类型只能通过分析，才能知道具体类型<br>现在ARM Thumb2指令集稍微好一点，会固化各种符号和类型，方便分析一些</li>
<li>编译属于多对多操作<br>主要是因为编译优化，或者故意混淆的手段，或者IAR编译时，没有生成符号表，从而导致缺乏一些分析辅助信息</li>
<li>反编译器依赖于语言和库<br>选对反编译器，才能正确反编译</li>
<li>反编译任何错误，都会影响反编译生成的效果</li>
</ol>
<h3 id="4_如何反汇编">4    如何反汇编</h3><p>最简单的工具，可以用各种IDE里面的binary工具，比如elfdump，直接导出符号表和汇编代码<br>但这种太简单了，不便于大型系统分析</p>
<p>理论上，反汇编的过程如下</p>
<ol>
<li><p>确定反汇编的代码区域<br>这个要看具体文件格式，比如elf之类的，直接包含各种section，可以分析<br>但bin，就要区分哪些是代码，哪些是数据，这是一个难点<br>我们可以换一个方向来看，对于STM32或者ARM Cortex系列的芯片来说，入口是固定的，我们直接找程序入口就可以了</p>
</li>
<li><p>找到入口地址，开始逐条分析<br>这里，可能需要进行表查找来获取数据；对应C语言来说，就是字符串表，变量表或者函数表</p>
</li>
<li><p>找到操作符和操作数，反编译成汇编指令</p>
</li>
<li><p>继续反汇编下一条指令</p>
</li>
</ol>
<h3 id="5_反汇编算法">5    反汇编算法</h3><p>主要有两种，也很简单</p>
<ol>
<li>线性法</li>
<li>递归下降法</li>
</ol>
<p><strong>线性法</strong>：就是逐条分析汇编，读取操作码，读取操作数，反汇编，然后下一条指令；理论上很简单，但容易出错，比如，我故意在汇编指令中<br>插入一些混淆数据，就可以扰乱反汇编器的输出；它的好处在于，能分析出所有的二进制代码<br>GDB和dbjdump都是采用线性分析法，他们因为有elf的各种辅助信息，在有代码的基础上调试，所以能知道哪些是有效数据，有效代码</p>
<p><strong>递归下降法</strong>：则是从另外一个方向来反汇编，就是从程序入口地址，然后分析下一条指令，顺序指令则直接继续分析，分支指令，比如if或者switch，则<br>直接分成两个反编译方向，依次反编译；或者跳转指令，就跳转到对应到地址。<br>也就是说，反编译器会尝试理解bin程序流，然后给出最佳的反汇编代码，但这样，也会有问题，机器毕竟是机器<br>想一下，我们在函数中，故意设置LR返回地址，估计反编译器就无能为力了。针对这种情况，我们可以用动态模拟器来调试，百试百灵</p>
<h3 id="6_最后">6    最后</h3><p>反汇编的过程就像填字游戏，给你有限信息，然后补齐整个游戏，还是挺好玩的</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hacker/">Hacker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDA/">IDA</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Raspberry-Pi-programming-IO" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/Raspberry-Pi-programming-IO/" class="article-date">
  	<time datetime="2015-10-26T16:50:39.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/Raspberry-Pi-programming-IO/">树莓派底层编程-GPIO篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0_前言">0    前言</h3><p>本来是准备写一篇用python控制GPIO的例子，结果发现太简单了，还是深入一些吧，多深入底层</p>
<p>接下来，我会按照下面的顺序来介绍：<br>1）GPIO控制器地址映射<br>2）GPIO主要控制寄存器介绍<br>3）GPIO操作流程<br>4）用C语言控制GPIO<br>6）用python来控制GPIO</p>
<h3 id="1_概述">1    概述</h3><p>树莓派2B采用的CPU为BCM2836，外设部分和BCM2835完全一致，所以就可以参考BCM2835的<a href="https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">寄存器手册</a><br>但是，这个寄存器手册笔误有点多，建议配合着wiki的<a href="http://elinux.org/BCM2835_datasheet_errata">勘误手册</a>来看</p>
<p>CPU总共有54个IO，每个IO都可以复用，配置输入或者输出模式，单从GPIO部分来看，比较简单，无非是输入／输出，触法模式等，和一般的MCU没有太大差异</p>
<h3 id="2_地址映射">2    地址映射</h3><p>BCM2835将BUS的地址空间，通过MMU映射到线性寻址空间，如下所示<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GPIO/">GPIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树莓派/">树莓派</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/27/Raspberry-Pi-programming-IO/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Note-on-compile-libnfc-and-mfoc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/22/Note-on-compile-libnfc-and-mfoc/" class="article-date">
  	<time datetime="2015-10-22T01:57:23.000Z" itemprop="datePublished">2015-10-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/22/Note-on-compile-libnfc-and-mfoc/">Note on compile libnfc and mfoc</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="概述">概述</h4><p>本文主要记录编译nfc-tools时遇到的问题以及解决方案</p>
<p>测试平台：Raspberry 2B＋</p>
<h3 id="1-_访问不了google_code，无法下载源码">1.    访问不了google code，无法下载源码</h3><p>mfc-tools 仓库已经从google转移到<a href="https://github.com/nfc-tools" target="_blank" rel="external">github</a>上</p>
<h3 id="2-_编译nfcuk和mfoc时，autoreconf失败">2.    编译nfcuk和mfoc时，autoreconf失败</h3><p>加入<code>-vis</code>参数，全部指令如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoreconf -vis&#10;automake&#10;autoconf&#10;./configure&#10;make</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_按照网上教程，需要修改str_nfc_target函数">3.    按照网上教程，需要修改<code>str_nfc_target</code>函数</h3><p>不需要，现已修复</p>
<h3 id="4-_在树莓派2B＋上使用配置nfc，无法打开SPI端口，提示”TFI_error”">4.    在树莓派2B＋上使用配置nfc，无法打开SPI端口，提示”TFI error”</h3><p>修改SPI速率参数，保持默认值即可，<code>/etc/nfc/libnfc.conf</code>全文如下</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow device auto-detection (default: true)</span></span><br><span class="line"><span class="comment"># Note: if this auto-detection is disabled, user has to set manually a device</span></span><br><span class="line"><span class="comment"># configuration using file or environment variable</span></span><br><span class="line"><span class="constant">allow_autoscan</span> = true</span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow intrusive auto-detection (default: false)</span></span><br><span class="line"><span class="comment"># Warning: intrusive auto-detection can seriously disturb other devices</span></span><br><span class="line"><span class="comment"># This option is not recommended, user should prefer to add manually his device.</span></span><br><span class="line"><span class="constant">allow_intrusive_scan</span> = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set log level (default: error)</span></span><br><span class="line"><span class="comment"># Valid log levels are (in order of verbosity): 0 (none), 1 (error), 2 (info), 3 (debug)</span></span><br><span class="line"><span class="comment"># Note: if you compiled with --enable-debug option, the default log level is "debug"</span></span><br><span class="line"><span class="constant">log_level</span> = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manually set default device (no default)</span></span><br><span class="line"><span class="comment"># To set a default device, you must set both name and connstring for your device</span></span><br><span class="line"><span class="comment"># Note: if autoscan is enabled, default device will be the first device available in device list.</span></span><br><span class="line"><span class="comment"># 错误配置</span></span><br><span class="line"><span class="comment">#device.name = "Itead_PN532_SPI"</span></span><br><span class="line"><span class="comment">#device.connstring = "pn532_spi:/dev/spidev0.0:500000"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确配置</span></span><br><span class="line">device.name = "Itead_PN532_SPI"</span><br><span class="line">device.connstring = "pn532_spi:/dev/spidev0.0"</span><br></pre></td></tr></table></figure>
<h3 id="5-_PN532无法识别门禁卡">5.    PN532无法识别门禁卡</h3><p>可以识别13.56MHz 高频IC卡，但无法识别125KHz 低频ID卡<br>NOTE: 可以自制125KHz天线，软件模拟ID卡射频协议</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NFC/">NFC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PN532/">PN532</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RFID/">RFID</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Do one thing and do it well
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>