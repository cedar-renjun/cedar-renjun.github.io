<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014 | Enjoy Programming</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Enjoy Programming">
<meta property="og:url" content="http://cedar-renjun.github.io//archives/2014/">
<meta property="og:image">
<meta property="og:site_name" content="Enjoy Programming">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Enjoy Programming">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Enjoy Programming" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Enjoy Programming</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Focus On Embedded System</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://cedar-renjun.github.io/"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-good-blog-about-coroutines" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/21/good-blog-about-coroutines/" class="article-date">
  <time datetime="2014-09-21T09:07:39.000Z" itemprop="datePublished">Sep 21 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/转载/">转载</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/21/good-blog-about-coroutines/">谈谈协程和C语言的协程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>注：</strong> 本文转自 <a href="http://www.yeolar.com/note/2013/02/17/coroutines/" target="_blank">http://www.yeolar.com/note/2013/02/17/coroutines/</a></p>
<p>晚上在整理我的 $HOME 的时候，发现了一段有趣的代码，它被保存为了a.c并存在了差不多半年之久。种种迹象表明，它很重要。其实我记得它，当初在网上看到，觉得它包含了一个巧妙的技巧，就让它长住在我的硬盘上了，今天我决定把它搬到这篇文章中。好吧，我是打算谈一谈协程的概念。</p>
<h2 id="一个例子">一个例子</h2>
<p>先给大家看一下这段代码：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <span class="keyword">int</span> i;
    <span class="keyword">int</span> num;
    <span class="keyword">int</span> state;
} task;

<span class="preprocessor">#define crBegin(state) \</span>
        <span class="keyword">switch</span> (state) { <span class="keyword">case</span> <span class="number">0</span>:

<span class="preprocessor">#define crReturn(state, ret) \</span>
        (state) = __LINE__; <span class="keyword">return</span> (ret); <span class="keyword">case</span> __LINE__:

<span class="preprocessor">#define crEnd() \</span>
        }

<span class="keyword">int</span> cb(task *t)
{
    crBegin(t-&gt;state);
    <span class="keyword">for</span> (;;) {
        t-&gt;num = <span class="number">1</span>;
        <span class="keyword">for</span> (t-&gt;i = <span class="number">0</span>; t-&gt;i &lt; <span class="number">20</span>; t-&gt;i++) {
            crReturn(t-&gt;state, t-&gt;num);
            t-&gt;num += <span class="number">1</span>;
        }
    }
    crEnd();
}

<span class="keyword">int</span> main()
{
    task t;
    <span class="keyword">int</span> i;

    t.state = <span class="number">0</span>;

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
        <span class="built_in">printf</span>(<span class="string">"%d "</span>, cb(&t));
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>它会输出5组1 ~ 20的数字。是不是有点晕，我们把宏展开再看一下 cb 函数。为了便于阅读，做了一些调整：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">int</span> cb(task *t)
{
    <span class="keyword">switch</span> (t-&gt;state) {
    <span class="keyword">case</span> <span class="number">0</span>:
        <span class="keyword">for</span> (;;) {
            t-&gt;num = <span class="number">1</span>;
            <span class="keyword">for</span> (t-&gt;i = <span class="number">0</span>; t-&gt;i &lt; <span class="number">20</span>; t-&gt;i++) {
                t-&gt;state = __LINE__ + <span class="number">2</span>;
                <span class="keyword">return</span> t-&gt;num;
    <span class="keyword">case</span> __LINE__:
                t-&gt;num += <span class="number">1</span>;
            }
        }
    }
}
</pre></td></tr></table></figure>

<p>看清楚了吗？这其实是 switch 的一个技巧，通过它实现了一种断点的效果，类似于Python的 yield 。它是一个非常简单的C的协程实现。</p>
<h3 id="协程的概念">协程的概念</h3>
<p>我们再看看 Wiki上对协程的解释 ：</p>
<blockquote>


<p>“<br>与子例程一样，协程也是一种程序组件。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务，迭代器，无限列表和管道。</p>
<p>因为相对于子例程协程可以有多个入口和出口点，可以用协程来实现任何的子例程。事实上，正如 Knuth 所说：“子例程是协程的特例。”</p>
<p>每当子例程被调用时，执行从被调用子例程的起始处开始；然而，接下来的每次协程被调用时，从协程返回（或屈服）的位置接着执行。</p>
<p>因为子例程只返回一次，要返回多个值就要通过集合的形式。这在有些语言，如 Forth， 里很方便，而其他语言，如 C ，只允许单一的返回值所以就需要引用一个集合。相反地，因为协程可以返回多次，返回多个值只需要在后继的协程调用中返回附加的值即可。在后继调用中返回附加值的协程常被称为产生器。</p>
<p>子例程容易实现于堆栈之上，因为子例程将调用的其他子例程作为下级。相反地，协程对等地调用其他协程，最好的实现是用 continuations（由有垃圾回收的堆实现）以跟踪控制流程。</p>
<p>在当今的主流编程环境里，线程是协程的合适的替代者，线程提供了用来管理“同时”执行的代码段实时交互的功能。因为要解决大量困难的问题，线程包括了许多强大和复杂的功能并导致了困难的学习曲线。当需要的只是一个协程时，使用线程就过于技巧了。然而——不像其他的替代者——在支持 C 的环境中，线程也是广泛有效的，对很多程序员也比较熟悉，并被很好地实现，文档化和支持。<br>”</p>
</blockquote>


<p>怎么样，现在是不是明白协程是怎么回事了？</p>
<h2 id="C语言的协程">C语言的协程</h2>
<p>关于C语言的协程编程，PuTTY的作者Simon Tatham写有一篇很棒的 文章 ，我们的一位同行张杰在看PuTTY代码时看到了作者对协程的使用，并给文章做了一份 翻译 ，在这里把译文给出（对照原文做了一些修改），同时在此表达对两位敬意。</p>
<h3 id="介绍">介绍</h3>
<p>设计大型程序一直都是件困难的事情，其中常常会遇到的一个难题是：一段生成数据的代码和一段处理这些数据的代码，让哪一个做调用函数，哪一个做被调函数？</p>
<p>下面是用于游程编码的解码器代码和解析器代码，都很简单：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">/* Decompression code */</span>
<span class="keyword">while</span> (<span class="number">1</span>) {
    c = getchar();
    <span class="keyword">if</span> (c == EOF)
        <span class="keyword">break</span>;
    <span class="keyword">if</span> (c == <span class="number">0xFF</span>) {
        len = getchar();
        c = getchar();
        <span class="keyword">while</span> (len--)
            emit(c);
    } <span class="keyword">else</span>
        emit(c);
}
emit(EOF);

<span class="comment">/* Parser code */</span>
<span class="keyword">while</span> (<span class="number">1</span>) {
    c = getchar();
    <span class="keyword">if</span> (c == EOF)
        <span class="keyword">break</span>;
    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c)) {
        <span class="keyword">do</span> {
            add_to_token(c);
            c = getchar();
        } <span class="keyword">while</span> (<span class="built_in">isalpha</span>(c));
        got_token(WORD);
    }
    add_to_token(c);
    got_token(PUNCT);
}
</pre></td></tr></table></figure>

<p>上面两段代码都很简单，易读易懂。第一段每次调用 emit() 生成一个字符；第二段每次调用 getchar() 消费一个字符。只要能想办法在调用 emit() 和 getchar() 时能让二者互相传数据，那么就能很容易地将这两段代码连到一起，从而将解码器的输出直接送进解析器。</p>
<p>很多现代操作系统中，在两个进程或线程之间使用管道就可以实现。解码器中的 emit() 向管道中写入数据，解析器的 getchar() 在管道的另一端读出数据，简单可靠，但是却不轻量也不易移植。而且也不值得为这么简单的任务将程序拆分成几个线程。</p>
<p>本文将给出一个极具创造性的方法来解决这种结构问题。</p>
<h3 id="重写">重写</h3>
<p>传统的方法是改写管道任意一端的代码，使其能够被调用。下面给出了如何对上面两段代码进行改写的例子。</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="keyword">int</span> decompressor(<span class="keyword">void</span>) {
    <span class="keyword">static</span> <span class="keyword">int</span> repchar;
    <span class="keyword">static</span> <span class="keyword">int</span> replen;
    <span class="keyword">if</span> (replen &gt; <span class="number">0</span>) {
        replen--;
        <span class="keyword">return</span> repchar;
    }
    c = getchar();
    <span class="keyword">if</span> (c == EOF)
        <span class="keyword">return</span> EOF;
    <span class="keyword">if</span> (c == <span class="number">0xFF</span>) {
        replen = getchar();
        repchar = getchar();
        replen--;
        <span class="keyword">return</span> repchar;
    } <span class="keyword">else</span>
        <span class="keyword">return</span> c;
}

<span class="keyword">void</span> parser(<span class="keyword">int</span> c) {
    <span class="keyword">static</span> <span class="keyword">enum</span> {
        START, IN_WORD
    } state;
    <span class="keyword">switch</span> (state) {
        <span class="keyword">case</span> IN_WORD:
        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c)) {
            add_to_token(c);
            <span class="keyword">return</span>;
        }
        got_token(WORD);
        state = START;
        <span class="comment">/* fall through */</span>

        <span class="keyword">case</span> START:
        add_to_token(c);
        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))
            state = IN_WORD;
        <span class="keyword">else</span>
            got_token(PUNCT);
        <span class="keyword">break</span>;
    }
}
</pre></td></tr></table></figure>

<p>当然了，你不必将两段程序都进行改写，只要改一段就行了。如果你将解码器改成上面那样，它每次调用会返回一个字符，那么只要将解析器中对 getchar() 的调用替换成对 decompressor() 的调用，就好了。相反地，如果你像上面那样改写了解析器，对每个输入字符调用一次，那么就可以将解码器中调用的 emit() 换成 parser() 。别把两个函数都改写成被调函数，除非你是想受罪。</p>
<p>其实这里已经暴露出一个问题。这两个改写过的函数都比原来的要难看。把这两个过程写成调用函数要比被调函数更易读。如果单单通过看代码来推断解析器所要解析的语法或者解码器所要处理的压缩格式，那么原来的两段代码都比改写后的代码要清晰些。所以我们最好是能不改写任何一段代码。</p>
<h3 id="Knuth的协程">Knuth的协程</h3>
<p>在《计算机程序设计艺术》一书中，Donald Knuth给出了一个解决这类问题的方法。他的方法是彻底抛弃栈的概念。别再考虑要有一个调用函数和一个被调函数，试着将它们想象成平等的，相互合作的。</p>
<p>用专业术语来说就是：将传统的“调用”原语用个稍微不同的“调用”来代替。这个新的“调用”能够将返回值保存在其它地方，而不是栈上，并且还能够跳转到由另一个已保存的返回值所指定的地址上。这样，解码器每次生成一个新的字符，就保存自己的程序计数器并跳转到上次离开解析器时的地址上；而对解析器来说，它每次需要一个新字符时，它保存自己的程序计数器并跳转到上一次离开解码器的地址上。程序可以这样在两个函数之间切换所需要的次数。</p>
<p>理论上，这样是不错。但实际中，我们却只能用汇编语言这么作，因为通用的高级语言没有一个支持协程调用原语。类似于C这样的语言全都要依赖于基于栈的结构，因此在函数间传递控制时，必须要有一个调用函数和一个被调函数。所以如果你想写可移植的代码，这个技术和使用Unix管道的方法一样不可行。</p>
<h3 id="基于栈的协程">基于栈的协程</h3>
<p>我们真正要的是找到C语言中能摹仿Knuth的协程调用原语的能力。我们必须接受这个现实：在C语言中，必须要有调用函数和被调函数。调用函数对我们来说没有任何问题，我们完全按照原算法写代码就行，无论什么时候，如果它生成(或者需要)一个字符，那就调用另外一个函数。</p>
<p>问题是出在被调函数上。对于被调函数，我们希望有一个“能从返回处再继续”的函数，也就是说从这个函数返回后，当再次调用它时，能从上次返回语句之后的位置继续运行。例如，我们希望能写出这样一个函数：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">int</span> function(<span class="keyword">void</span>) {
    <span class="keyword">int</span> i;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)
        <span class="keyword">return</span> i;   <span class="comment">/* won't work, but wouldn't it be nice */</span>
}
</pre></td></tr></table></figure>

<p>连续对它调用10次，它能分别返回0到9.</p>
<p>我们该怎样实现呢？其实我们可以利用 goto 语句跳转到函数中的任意一点。如果我们在函数中加入一个状态变量，我们就可以这样实现：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">int</span> function(<span class="keyword">void</span>) {
    <span class="keyword">static</span> <span class="keyword">int</span> i, state = <span class="number">0</span>;
    <span class="keyword">switch</span> (state) {
        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">goto</span> LABEL0;
        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">goto</span> LABEL1;
    }
    LABEL0: <span class="comment">/* start of function */</span>
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        state = <span class="number">1</span>; <span class="comment">/* so we will come back to LABEL1 */</span>
        <span class="keyword">return</span> i;
        LABEL1:; <span class="comment">/* resume control straight after the return */</span>
    }
}
</pre></td></tr></table></figure>

<p>这个方法是可行的。我们在所有可能需要恢复执行的位置都加上标签：起始位置加一个，还有所有 return 语句之后都加一个。我们在状态变量中保存每次调用这个函数时的状态，这样它就能在我们下次调用时告诉我们应该跳到哪个标签上。每次返回前，更新状态变量，指向到正确的标签；不论调用多少次，针对状态变量的 switch 语句都能找到我们要跳转到的位置。</p>
<p>但这还是难看得很。最糟糕的部分是所有的标签都需要手工维护，还必须保证函数中的标签和开头 switch 语句中的一致。每次新增一个 return 语句，就必须想一个新的标签名并将其加到 switch 语句中；每次删除 return 语句时，同样也必须删除对应的标签。这使得维护代码的工作量增加了一倍。</p>
<h3 id="Duff的装置">Duff的装置</h3>
<p>C语言中著名的Duff装置利用了一个事实： switch 的 case 语句，即使放在 switch 的一个子块中，仍然是合法的。Tom Duff利用这一点给出了一个优化的输出循环：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">switch</span> (count % <span class="number">8</span>) {
    <span class="keyword">case</span> <span class="number">0</span>:        <span class="keyword">do</span> {  *to = *from++;
    <span class="keyword">case</span> <span class="number">7</span>:              *to = *from++;
    <span class="keyword">case</span> <span class="number">6</span>:              *to = *from++;
    <span class="keyword">case</span> <span class="number">5</span>:              *to = *from++;
    <span class="keyword">case</span> <span class="number">4</span>:              *to = *from++;
    <span class="keyword">case</span> <span class="number">3</span>:              *to = *from++;
    <span class="keyword">case</span> <span class="number">2</span>:              *to = *from++;
    <span class="keyword">case</span> <span class="number">1</span>:              *to = *from++;
                   } <span class="keyword">while</span> ((count -= <span class="number">8</span>) &gt; <span class="number">0</span>);
}
</pre></td></tr></table></figure>

<p>我们可以把这个技巧用在协程上。不用 switch 语句来决定要跳转到哪里去执行，而是直接利用 switch 语句本身来实现跳转：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">int</span> function(<span class="keyword">void</span>) {
    <span class="keyword">static</span> <span class="keyword">int</span> i, state = <span class="number">0</span>;
    <span class="keyword">switch</span> (state) {
        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* start of function */</span>
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
            state = <span class="number">1</span>; <span class="comment">/* so we will come back to "case 1" */</span>
            <span class="keyword">return</span> i;
            <span class="keyword">case</span> <span class="number">1</span>:; <span class="comment">/* resume control straight after the return */</span>
        }
    }
}
</pre></td></tr></table></figure>

<p>现在看到希望了。我们要做的事情就是精心构造抽取出几个宏来，将这种看起来不伦不类的实现用一些看起来更结构化的语句隐藏起来：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="preprocessor">#define crBegin static int state=0; switch(state) { case 0:</span>
<span class="preprocessor">#define crReturn(i,x) do { state=i; return x; case i:; } while (0)</span>
<span class="preprocessor">#define crFinish }</span>
<span class="keyword">int</span> function(<span class="keyword">void</span>) {
    <span class="keyword">static</span> <span class="keyword">int</span> i;
    crBegin;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)
        crReturn(<span class="number">1</span>, i);
    crFinish;
}
</pre></td></tr></table></figure>

<p><strong>注意：</strong> 使用 do … while(0) 是为了确保 crReturn 出现在 if … else 之间时不需要使用大括号将它包裹起来</p>
<p>好了，这基本上就是我们想要的了。我们可以使用 crReturn 将函数返回，并能够在下次调用时从返回的位置之后继续执行。当然，我们必须要遵守几条规则（函数体要嵌在 crBegin 和 crFinish 之间；所有需要跨 crReturn 使用的局部变量都要定义成 static 变量；不能把 crReturn 放在其他 switch 语句中）；不过这几条规则对我们并没有太大限制。</p>
<p>现在就剩下一个问题了，就是 crReturn 的第一个参数。就像在上一节中我们每增加一个新的标签都要考虑防止标签名重复一样，现在我们必须保证 crReturn 的第一个参数不能相同。其实就算重名的话，后果也不严重 —— 编译器能够发现这个错误，因此不会在运行时导致严重后果 —— 但我们还是要避免这个问题。</p>
<p>这个问题是能够解决的。ANSI C提供了 <strong>LINE</strong> 宏，这个宏展开后是当前代码行的行号，接下来我们就修改一下 crReturn ：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">#define crReturn(x) do { state=__LINE__; return x; \</span>
                         <span class="keyword">case</span> __LINE__:; } <span class="keyword">while</span> (<span class="number">0</span>)
</pre></td></tr></table></figure>

<p>现在我们就不用再担心那些关于状态参数了，只是增加了第四条规则（不要将2个 crReturn 语句放在同一行）。</p>
<h3 id="评估">评估</h3>
<p>现在我们有了这个东西，就可以用它再来改写一下原来那两段代码了。</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="keyword">int</span> decompressor(<span class="keyword">void</span>) {
    <span class="keyword">static</span> <span class="keyword">int</span> c, len;
    crBegin;
    <span class="keyword">while</span> (<span class="number">1</span>) {
        c = getchar();
        <span class="keyword">if</span> (c == EOF)
            <span class="keyword">break</span>;
        <span class="keyword">if</span> (c == <span class="number">0xFF</span>) {
            len = getchar();
            c = getchar();
            <span class="keyword">while</span> (len--)
                crReturn(c);
        } <span class="keyword">else</span>
            crReturn(c);
    }
    crReturn(EOF);
    crFinish;
}

<span class="keyword">void</span> parser(<span class="keyword">int</span> c) {
    crBegin;
    <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="comment">/* first char already in c */</span>
        <span class="keyword">if</span> (c == EOF)
            <span class="keyword">break</span>;
        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c)) {
            <span class="keyword">do</span> {
                add_to_token(c);
               crReturn( );
            } <span class="keyword">while</span> (<span class="built_in">isalpha</span>(c));
            got_token(WORD);
        }
        add_to_token(c);
        got_token(PUNCT);
        crReturn( );
    }
    crFinish;
}
</pre></td></tr></table></figure>

<p>我们已经把解码器和解析器都改写成了被调函数，它们不需要像上次那样的大规模的重构工作了。每个函数的结构完全是原来算法的翻版。读代码的人能够推出解析器所能识别的语法，也能推出解码器所使用的压缩格式，与读那两段使用状态机来实现的代码比起来，这要容易多了。一旦你适应了这种新的代码形式，就会发现这两段代码的控制流程相当直观：解码器产生出一个字符时，它就调用 crReturn 将这个字符传给调用函数，并等待当需要下一个字符时再次被调用；当解析器需要一个字符时，它就通过 crReturn 返回，并等待下一次被调用时通过参数 c 传入新的字符。</p>
<p>不过，代码中还是有一处小小的结构调整： getchar() （其实，在改写的代码中是 crReturn ）放在了 parser() 的循环的结尾，而不是开头，这是因为在进入函数时，第一个字符已经通过 c 传进来了。我们应该能接受这个结构上的小改动，要是你真的对此感觉强烈，可以这样认为：在开始向 parser() 送入数据之前，它需要一次初始化调用。</p>
<p>当然，和前面一样，我们不必把两个函数都用协程的宏改写。改一个就足够了，另一个可以作为它的调用函数。</p>
<p>我们已经实现了文章开始时的目标：一个可移植的ANSI C方法，解决数据在生产者和消费者之间的传递问题，而不必把代码用状态机重写。我们用 switch 语句的一个很少用到的特性，结合C语言的预处理器，构造出一个隐式的状态机，进而实现了我们的目标。</p>
<h3 id="编程规范">编程规范</h3>
<p>显然，这个技巧跟每本编程规范书中的内容都相悖。如果你在公司的代码中这样用，你很有可能会受到指责，并因为这种不遵守纪律的行为而被警告：你的宏定义中大括号没有匹配完整，在子代码块中包含了未用到的 case ，还有 crReturn 中乱七八糟的不完整的内容… 写出这样不负责任的代码，不炒了你才怪。你应该为此感到羞愧。</p>
<p>我要声明将编程规范用在这里是不对的。文章里给出的示例代码不是很长，也不很复杂，即便以状态机的方式改写还是能够看懂的。但是随着代码越来越长，改写的难度将越来越大，改写对直观性造成的损失也变得相当相当大。</p>
<p>想一想，一个函数如果包含这样的小代码块：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">case</span> STATE1:
<span class="comment">/* perform some activity */</span>
<span class="keyword">if</span> (condition) state = STATE2; <span class="keyword">else</span> state = STATE3;
</pre></td></tr></table></figure>

<p>对于看代码的人说，这和包含下面小代码块的函数没有多大区别</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>LABEL1:
<span class="comment">/* perform some activity */</span>
<span class="keyword">if</span> (condition) <span class="keyword">goto</span> LABEL2; <span class="keyword">else</span> <span class="keyword">goto</span> LABEL3;
</pre></td></tr></table></figure>

<p>一个是调用函数，另一个是被调函数。是的，这两个函数的结构在视觉上是一样的，而对于函数中实现的算法，两个函数都一样不利于查看。因为你使用协程的宏而炒你鱿鱼的人，一样会因为你写的函数是由小块的代码和 goto 语句组成而吼着炒了你。只是这次他们没有冤枉你，因为像那样设计的函数会严重扰乱算法的结构。</p>
<p>编程规范的目标就是为了代码清晰。如果将一些重要的东西，象 switch 、 return 以及 case 语句，隐藏到起“障眼”作用的宏中，从编程规范的角度讲，可以说你扰乱了程序的语法结构，并且违背了代码清晰这一要求。但是我们这样做是为了突出程序的算法结构，而算法结构恰恰是看代码的人更想了解的。</p>
<p>任何编程规范，如果非要牺牲算法清晰度来换取语法的清晰度，都应该进行修改。如果你的上司因为使用了这一技巧而解雇你，那么在保安把你往外拖的时候要不断告诉他这一点。</p>
<h3 id="提炼及编码">提炼及编码</h3>
<p>在正规的应用程序中，这个协程的实现很少能用得上，因为它用到了静态变量，因此是不可重入的，也不能支持多线程。理想情况下，在一个实际的应用程序中，你会希望能在几个不同的上下文中调用同一个函数，并且每次在某个上下文中调用这个函数时，都能在这个上下文中上一次返回的位置之后恢复执行。</p>
<p>这非常容易实现。我们给函数增加一个新的参数，一个指向上下文结构体的指针；我们将所有的局部变量还有协程用到的状态变量都声明成结构体中的元素。</p>
<p>这确实有点难看，因为你突然不能用 i 作为循环计数，而要用 ctx-&gt;i ；事实上，所有重要的变量都成了协程上下文结构体中的成员。但是，这解决了重入的问题，并且没影响到函数的结构。</p>
<p>（当然，要是C语言支持Pascal语言的 with 语句，我们就可以将这个间接的引用隐藏掉。但是很遗憾。而对于C++语言，我们可以把协程的两个函数设计成类的成员函数，所有的局部变量设计成类的成员变量，从而将作用域的问题隐藏掉。）</p>
<p>这里引用的C语言头文件实现了一套预定义的协程使用的宏。文件中定义了2套宏函数，前缀分别是 scr 和 ccr 。 scr 宏是一套简单的实现，用于可以使用静态变量的情况； ccr 宏更高级一些，能支持重入。在头文件的注释中有完整的说明。</p>
<p>需要注意的是，VC++ 6并不喜欢这种协程技巧，因为其默认的debug状态（Program Database for Edit and Continue）对 <strong>LINE</strong> 宏的支持有点儿怪。如果想用VC++ 6编译一个使用了协程的宏，你就要关掉Edit and Continue。（在project settings中，选择c/c++标签，在General中，将Debug info改为Program Database for Edit and Continue之外的其他值)。</p>
<p>（这个头文件是MIT许可的，所以你可以任意使用，没有任何限制。如果你发现MIT对你的使用方式有限制，可以给我发邮件，我会考虑给你授权。）</p>
<p>使用 这个链接 获得coroutine.h。</p>
<p>感谢您的阅读。共享并享受共享吧！</p>
<h3 id="参考文献">参考文献</h3>
<ul>
<li><p>Donald Knuth, The Art of Computer Programming, Volume 1. Addison-Wesley, ISBN 0-201-89683-4. Section 1.4.2 描述了协程的最原始的形式。</p>
</li>
<li><p><a href="http://www.lysator.liu.se/c/duffs-device.html" target="_blank">http://www.lysator.liu.se/c/duffs-device.html</a> 是Tom Duff自己对Duff装置的讨论。注意，文章的最后似乎暗示了Duff自己也发明了这种协程或者类似的技巧。<br><br/>2005-03-07更新： Tom Duff在一篇博客的评论中确认了 ，在他原来的邮件中写到：”一种叛逆的使用 switch 语句的方法来实现中断驱动的状态机”，这实际上和我在这里描述的方法是一样的。</p>
</li>
<li><p>PuTTY 是一个Win32的Telnet和SSH的客户端软件。其中的SSH协议的实现就是使用协程技巧的一个示例。就我目前所知，这部分代码是正规工程的代码中，最难hack的C代码。</p>
</li>
</ul>
<h3 id="结语">结语</h3>
<p>好了，Simon大叔的话说完了。大家鼓掌，太精彩了！当然，这个技巧的用途不广，但是这篇文章非常详细地解释了协程的概念和实际场景，以及在C语言中的一些解决思路。</p>
<p>现在回过头来看开始的那段代码，你就完全明白了吧。（我终于把a.c清理出去了）</p>
<p>关于协程的话题就到此为止，感兴趣可以看看Wiki上列出的一些使用了协程概念的语言和库。比如Erlang、Lua、Stackless Python。</p>
<h3 id="引用和参考资料">引用和参考资料</h3>
<ul>
<li><a href="http://www.oschina.net/code/snippet_116913_14796" target="_blank">http://www.oschina.net/code/snippet_116913_14796</a></li>
<li><a href="http://zh.wikipedia.org/wiki/协程" target="_blank">http://zh.wikipedia.org/wiki/协程</a></li>
<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_55119d4d0100ono5.html" target="_blank">http://blog.sina.com.cn/s/blog_55119d4d0100ono5.html</a></li>
<li><a href="http://bbs.chinaunix.net/thread-1833313-1-1.html" target="_blank">http://bbs.chinaunix.net/thread-1833313-1-1.html</a></li>
<li><a href="http://www.cnblogs.com/edwardlost/archive/2010/11/02/1861742.html" target="_blank">http://www.cnblogs.com/edwardlost/archive/2010/11/02/1861742.html</a></li>
<li><a href="http://www.yeolar.com/note/2013/02/17/coroutines/" target="_blank">http://www.yeolar.com/note/2013/02/17/coroutines/</a></li>
</ul>
<p><strong>后注：</strong><br>感谢作者Simon写出这篇精彩博文，<a href="http://www.yeolar.com/" target="_blank">http://www.yeolar.com/</a>这里有更多精品，感兴趣的同学可以关注一下</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/09/21/good-blog-about-coroutines/" data-id="12tz0ds6r4s7ziub" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-state-machine-timer-resource-management" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/17/state-machine-timer-resource-management/" class="article-date">
  <time datetime="2014-09-17T07:00:29.000Z" itemprop="datePublished">Sep 17 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/教程/">教程</a>►<a class="article-category-link" href="/categories/教程/框架/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/17/state-machine-timer-resource-management/">在状态机中管理时间资源</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面的话">写在前面的话</h2>
<p>在嵌入式系统中，经常会使用到延时(Delay)函数，延时有长，有短；500us以下的延时，可以完全用软件来做；较长的延时，可以用硬件Timer或者调用RTOS的时间管理函数。</p>
<p>在简单的MCU中，由于资源限制，无法使用常规的RTOS，这时就需要自己写相应的协调式调度算法，常见的有协程和时间片轮询机制等，万变不离其宗，它们其中的核心是状态机，在状态机中一个核心原则是：<strong>函数不能长时间阻塞MCU</strong>，否则就会导致整个系统调度失效。也就是说：<strong>无法使用纯软件延时</strong></p>
<p>例如，在系统中严禁出现下面代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>
<span class="keyword">void</span> delay_s(uint8_t tick_s)
{
    ...
}


...


<span class="comment">// Code Snippet 1</span>

delay_s(<span class="number">2</span>);

<span class="comment">// Code Snippet 2</span>
</pre></td></tr></table></figure>

<p><strong>注：</strong><br>关于状态机，后面会专门写文章来介绍，这里暂且略过；如果您感兴趣，请自行 百度/google 下面关键字</p>
<p><strong>FSM/HSM/状态机</strong></p>
<p><br/></p>
<h2 id="原理分析">原理分析</h2>
<p>下面讨论下怎么处理这种情况</p>
<p>传统软件延时的核心问题是：<strong>没有一个统一的全局时间，所以各个函数只好自己空转来延时；在空转时，也不会释放MCU，<br>所以导致无法执行其它函数，在OS的环境下，时间资源由RTOS统一接管，调度；无OS的情况下，我们便需要自己来管理时间资源</strong></p>
<p>在APP层，用户使用场景规定如下：</p>
<ol>
<li>函数需要延时</li>
<li>向系统申请时间资源</li>
<li>任务获取句柄</li>
<li>任务中，查询定时时间是否到达</li>
</ol>
<p>实现机制如下：</p>
<p>在系统级别维护一个全局Timer值，该值会不断递增，同时在内部维护一个时间单元数组（链表）<br>，当用户申请时间资源时，系统查询一个空闲时间单元，将当前时间加上延时值，存储到时间单元结构体中，然后标记单元为占用状态，<br>返回时间单元ID（即为句柄）</p>
<p>注：当定时时间到达后，原来获取的句柄变会失效，如需重新使用延时服务，请重新申请句柄</p>
<h2 id="代码实现">代码实现</h2>
<p>详细的代码如下：</p>
<figure class="highlight C"><figcaption><span>H文件代码</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="code"><pre>
<span class="comment">//******************************************************************************************</span>
<span class="comment">//!</span>
<span class="comment">//! \file   SoftTimer.h</span>
<span class="comment">//! \brief  SoftTimer Interface File</span>
<span class="comment">//!         This module is used to replace 'delay' function in state machine</span>
<span class="comment">//! \author cedar</span>
<span class="comment">//! \date   2014-9-17</span>
<span class="comment">//! \email  xuesong5825718@gmail.com</span>
<span class="comment">//! \qq     819280802</span>
<span class="comment">//!</span>
<span class="comment">//! \license</span>
<span class="comment">//!</span>
<span class="comment">//! Copyright (c) 2014 Cedar MIT License</span>
<span class="comment">//!</span>
<span class="comment">//! Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="comment">//! of this software and associated documentation files (the "Software"), to deal</span>
<span class="comment">//! in the Software without restriction, including without limitation the rights to</span>
<span class="comment">//! use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</span>
<span class="comment">//! the Software, and to permit persons to whom the Software is furnished to do so,</span>
<span class="comment">//! subject to the following conditions:</span>
<span class="comment">//!</span>
<span class="comment">//! The above copyright notice and this permission notice shall be included in all</span>
<span class="comment">//! copies or substantial portions of the Software.</span>
<span class="comment">//!</span>
<span class="comment">//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="comment">//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="comment">//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="comment">//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="comment">//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="comment">//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span>
<span class="comment">//! IN THE SOFTWARE.</span>
<span class="comment">///</span>
<span class="comment">//******************************************************************************************</span>

<span class="preprocessor">#ifndef __SOFT_TIMER_H__</span>
<span class="preprocessor">#define __SOFT_TIMER_H__</span>

<span class="preprocessor">#ifdef __cplusplus</span>
<span class="keyword">extern</span> <span class="string">"C"</span>
{
<span class="preprocessor">#endif</span>

<span class="comment">//******************************************************************************************</span>
<span class="comment">//!                           Portable Configure</span>
<span class="comment">//******************************************************************************************</span>

<span class="comment">//! If your compiler support stdint.h file, then try to use it, otherwise using folling section</span>
<span class="preprocessor">#if 0</span>
<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>      uint8_t ;
<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> uint16_t;
<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>       uint32_t;
<span class="preprocessor">#endif</span>

<span class="preprocessor">#define ENTER_SECURE_SECTION()     \</span>
<span class="keyword">do</span>                                 \
{                                  \
} <span class="keyword">while</span> (<span class="number">0</span>)


<span class="preprocessor">#define EXIT_SECURE_SECTION()      \</span>
<span class="keyword">do</span>                                 \
{                                  \
} <span class="keyword">while</span> (<span class="number">0</span>)



<span class="comment">//******************************************************************************************</span>
<span class="comment">//!                           Function Parameters</span>
<span class="comment">//******************************************************************************************</span>

<span class="preprocessor">#define TIMER_ELEMENT_NUM_MAX      20                      <span class="comment">//!&lt; Maxium SoftTimer</span></span>

<span class="preprocessor">#define SOFT_TIMER_SUCCESS         0                       <span class="comment">//!&lt; Operate success</span></span>
<span class="preprocessor">#define SOFT_TIMER_ING             1                       <span class="comment">//!&lt; Timer Counting</span></span>
<span class="preprocessor">#define SOFT_TIMER_TIMEOUT         2                       <span class="comment">//!&lt; Timer Timeout</span></span>
<span class="preprocessor">#define SOFT_TIMER_ERR             3                       <span class="comment">//!&lt; Operate failure, invaild handle</span></span>


<span class="comment">//******************************************************************************************</span>
<span class="comment">//!                           PUBLIC API</span>
<span class="comment">//******************************************************************************************</span>

<span class="keyword">extern</span> uint16_t SoftTimer_Init(<span class="keyword">void</span>);
<span class="keyword">extern</span> uint16_t SoftTimer_Req(uint32_t Delay);
<span class="keyword">extern</span> uint16_t SoftTimer_Check(uint16_t Handle);
<span class="keyword">extern</span> <span class="keyword">void</span> TimerISR_Hook(<span class="keyword">void</span>);

<span class="preprocessor">#ifdef __cplusplus</span>
}
<span class="preprocessor">#endif</span>

<span class="preprocessor">#endif <span class="comment">// __SOFT_TIMER_H__</span></span>
</pre></td></tr></table></figure>


<figure class="highlight C"><figcaption><span>C文件代码</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
</pre></td><td class="code"><pre>
<span class="comment">//******************************************************************************************</span>
<span class="comment">//!</span>
<span class="comment">//! \file   SoftTimer.c</span>
<span class="comment">//! \brief  SoftTimer Implement File</span>
<span class="comment">//!         This module is used to replace 'delay' function in state machine</span>
<span class="comment">//! \author cedar</span>
<span class="comment">//! \date   2014-9-17</span>
<span class="comment">//! \email  xuesong5825718@gmail.com</span>
<span class="comment">//! \qq     819280802</span>
<span class="comment">//!</span>
<span class="comment">//! \license</span>
<span class="comment">//!</span>
<span class="comment">//! Copyright (c) 2014 Cedar MIT License</span>
<span class="comment">//!</span>
<span class="comment">//! Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="comment">//! of this software and associated documentation files (the "Software"), to deal</span>
<span class="comment">//! in the Software without restriction, including without limitation the rights to</span>
<span class="comment">//! use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</span>
<span class="comment">//! the Software, and to permit persons to whom the Software is furnished to do so,</span>
<span class="comment">//! subject to the following conditions:</span>
<span class="comment">//!</span>
<span class="comment">//! The above copyright notice and this permission notice shall be included in all</span>
<span class="comment">//! copies or substantial portions of the Software.</span>
<span class="comment">//!</span>
<span class="comment">//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="comment">//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="comment">//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="comment">//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="comment">//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="comment">//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span>
<span class="comment">//! IN THE SOFTWARE.</span>
<span class="comment">///</span>
<span class="comment">//******************************************************************************************</span>

<span class="preprocessor">#include "SoftTimer.h"</span>


<span class="comment">//******************************************************************************************</span>
<span class="comment">//!                     Typedef</span>
<span class="comment">//******************************************************************************************</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    uint16_t handle;                                       <span class="comment">// Timer Resource Handle</span>
    uint32_t delay;                                        <span class="comment">// Delay Value</span>
    uint32_t timestamp;                                    <span class="comment">// Timer Stamp</span>
}TimerElem_t;


<span class="comment">//******************************************************************************************</span>
<span class="comment">//!                     Private Variable</span>
<span class="comment">//******************************************************************************************</span>

<span class="keyword">static</span> <span class="keyword">volatile</span> uint32_t TimerCnt    = <span class="number">0</span>;
<span class="keyword">static</span> <span class="keyword">volatile</span> uint16_t HandleIndex = <span class="number">0</span>;
<span class="keyword">static</span> TimerElem_t       SoftTimer[TIMER_ELEMENT_NUM_MAX];


<span class="comment">//******************************************************************************************</span>
<span class="comment">//!                     Function Implement</span>
<span class="comment">//******************************************************************************************</span>


<span class="comment">//******************************************************************************************</span>
<span class="comment">//</span>
<span class="comment">//! \brief  Initialize Timer resource</span>
<span class="comment">//!</span>
<span class="comment">//! \param  None.</span>
<span class="comment">//! \retval </span>
<span class="comment">//!         - SOFT_TIMER_SUCCESS</span>
<span class="comment">//!</span>
<span class="comment">//! \note</span>
<span class="comment">//!         - This function must be called first !.</span>
<span class="comment">//!         </span>
<span class="comment">//</span>
<span class="comment">//******************************************************************************************</span>
uint16_t SoftTimer_Init(<span class="keyword">void</span>)
{
    uint8_t i = <span class="number">0</span>;

    <span class="comment">// Clear All Elements</span>
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; TIMER_ELEMENT_NUM_MAX; i++)
    {
        SoftTimer[i].handle    = <span class="number">0</span>;
        SoftTimer[i].delay     = <span class="number">0</span>;
        SoftTimer[i].timestamp = <span class="number">0</span>;
    }

    <span class="comment">// Initialize Global Status Variable</span>
    TimerCnt    = <span class="number">0</span>;
    HandleIndex = <span class="number">1</span>;

    <span class="keyword">return</span> (SOFT_TIMER_SUCCESS);
}

<span class="comment">//******************************************************************************************</span>
<span class="comment">//</span>
<span class="comment">//! \brief  Request Timer resource</span>
<span class="comment">//!</span>
<span class="comment">//! \param  [in] Tick is time eclipse value.</span>
<span class="comment">//! \retval </span>
<span class="comment">//!         - Zero                     Operate Failure, No Timer Available</span>
<span class="comment">//!         - Non-Zero                 Valid Timer Handle</span>
<span class="comment">//!</span>
<span class="comment">//! \note</span>
<span class="comment">//!         - Timer handle only can be used once.</span>
<span class="comment">//!         </span>
<span class="comment">//</span>
<span class="comment">//******************************************************************************************</span>
uint16_t SoftTimer_Req(uint32_t Tick)
{
    uint8_t i = <span class="number">0</span>;

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_ELEMENT_NUM_MAX; i++)
    {
        <span class="keyword">if</span> (SoftTimer[i].handle == <span class="number">0</span>)
        {

            ENTER_SECURE_SECTION();

            <span class="comment">// Timer Handle != 0</span>
            <span class="keyword">if</span> (++HandleIndex == <span class="number">0</span>)
            {
                ++HandleIndex;
            }

            SoftTimer[i].handle    = HandleIndex;
            SoftTimer[i].delay     = Tick;
            SoftTimer[i].timestamp = Tick + TimerCnt;

            EXIT_SECURE_SECTION();

            <span class="keyword">return</span> (HandleIndex);
        }
    }

    <span class="keyword">return</span> (<span class="number">0</span>);
}

<span class="comment">//******************************************************************************************</span>
<span class="comment">//</span>
<span class="comment">//! \brief  Check Timer status</span>
<span class="comment">//!         You can check register timer status at any time.</span>
<span class="comment">//!</span>
<span class="comment">//! \param  [in] Handle is Timer Handle, which you can get it from \ref SoftTimer_Req.</span>
<span class="comment">//! \retval </span>
<span class="comment">//!         - \ref SOFT_TIMER_ING      Timer Counting</span>
<span class="comment">//!         - \ref SOFT_TIMER_TIMEOUT  Timer TimeOut</span>
<span class="comment">//!         - \ref SOFT_TIMER_ERR      Invalid Timer Handle</span>
<span class="comment">//!</span>
<span class="comment">//! \note</span>
<span class="comment">//!         - You must call \ref SoftTimer_Req to request an valid timer handle.</span>
<span class="comment">//!         - Timer handle only can be used once.</span>
<span class="comment">//!         </span>
<span class="comment">//</span>
<span class="comment">//******************************************************************************************</span>
uint16_t SoftTimer_Check(uint16_t Handle)
{
    uint8_t i = <span class="number">0</span>;

    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; TIMER_ELEMENT_NUM_MAX; i++)
    {
        <span class="keyword">if</span>(SoftTimer[i].handle ==  Handle)
        {
            ENTER_SECURE_SECTION();
            <span class="keyword">if</span>(SoftTimer[i].delay + TimerCnt &lt; SoftTimer[i].timestamp)
            {
                <span class="keyword">return</span> (SOFT_TIMER_ING);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">return</span> (SOFT_TIMER_TIMEOUT);
            }
            EXIT_SECURE_SECTION();
        }
    }

    <span class="keyword">return</span> (SOFT_TIMER_ERR);
}


<span class="comment">//******************************************************************************************</span>
<span class="comment">//</span>
<span class="comment">//! \brief  SoftTimer Hook Function</span>
<span class="comment">//!         This callback function must be called interval</span>
<span class="comment">//!</span>
<span class="comment">//! \note   Typical 1ms interval</span>
<span class="comment">//</span>
<span class="comment">//******************************************************************************************</span>
<span class="keyword">void</span> TimerISR_Hook(<span class="keyword">void</span>)
{
    TimerCnt++;
}
</pre></td></tr></table></figure>

<p>最新代码，请到<a href="https://github.com/cedar-renjun/Codesnippet/tree/master/SoftTimer" target="_blank">https://github.com/cedar-renjun/Codesnippet/tree/master/SoftTimer</a>获取</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/09/17/state-machine-timer-resource-management/" data-id="ku49g7q5gihbdeu8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-missing-you" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/01/missing-you/" class="article-date">
  <time datetime="2014-09-01T14:33:39.000Z" itemprop="datePublished">Sep 1 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/杂谈/">杂谈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/01/missing-you/">那些人，珍重便好</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>


<p>“人生有时候，总是很讽刺。一转身可能就是一世。说好永远的，不知怎么就散了。最后自己想来想去竟然也搞不清当初是什么原因分开彼此的。然后，你忽然醒悟，感情原来是这么脆弱的。经得起风雨，却经不起平凡；风雨同船，天晴便各自散了。也许只是赌气，也许只是因为小小的事。幻想着和好的甜蜜，或重逢时的拥抱，那个时候会是边流泪边捶打对方，还傻笑着。该是多美的画面。没想到的是，一别竟是一辈子了。”</p>
<footer><strong>张爱玲 《有些人我们一直在错过》</strong></footer></blockquote>


<pre><code>有些人，渐行渐远
有些人，来去如风
有些人，或许不会再见
有些人，珍重便好
</code></pre><p>某年回家，在车上偶遇多年未见的同学，一路上聊起来，我问他是怎么认出我来的，他说：“这些年你都没有怎么变”，我笑笑说：“还是跟以前一样傻逼吧”，他也笑笑。他说：“你现在在哪工作”，“武汉读书”，忽然他就提高了音调，“还在读书呀，读大学吧，你看你都读老了，不要读成书呆子”，接着自顾自地说了一堆，“我们打工的那个厂里面一堆大学生，你看现在，什么都缺，就是不缺大学生，读书有什么用，你读出来还不是跟我一样去打工……”听着他唠叨了一大堆，我就只有颔首而笑的份，我明白，我只有用笑容来表示我对他的尊重。下车前，我们互留了电话号码，告别以留下“常联系”这句话后的背影作为结束。号码也只是藏在电话本里的某个角落，只有在过年的时候才会互道一声问候，虽然想打电话联系，但是不知道说什么好，怕尴尬，怕那种只能挤出牙缝的陌生，索性在某次清理通讯录的时候，我把他从我的通讯录里删除了。</p>
<p>这让我想起了我一位高中同学，很长一段时间，我和他坐同桌。他平时就是打篮球，上网和睡觉，篮球打得很棒，各方面也不错，但是有一点，就是不喜欢学习，考试都是比较糟糕。曾想过帮他，但是后来发现这是一件很难的事情，人各有志，命里无时莫强求，也许学习这条路对于每个人并不是都是合适的，每个人都有适合自己的事做，最后高考考完他就消失了，填志愿的时候他也没来，还没来得及道别，后来QQ上也没见他上过线。常言道“天下没有不散的宴席”，但有时却是，宴席还没有摆上，还没来得及陪君醉笑三千场，不诉离殇，就有人抽身而去，连一个身影都没有留下。后来有一次，辗转了解到毕业后他就回家了，之后喜当爹了，现在孩子应该可以打酱油了吧，也不知道他现在在做什么，希望应该比学习有趣吧。</p>
<p>打开邮箱，看到同学发来的这样一份邮件，“毕业的，没毕业的，上班的，没上班的，我们都开始忙碌了；好像越来越少有时间，去问候和想念；会不会有天，我们真的都忘记了彼此，遗忘了那些最美丽的回忆？我们曾在某个时间相遇，曾在某个时段某个时候，在一起。然后，因为这样那样的原因，我们不常联系。只是想轻轻地告诉你：我很好，希望你也很好。”看到这个心里觉得矫情，但我们终究会明白，每个人总会走上自己选择的路，不管怎样，还是希望听到他们的好消息。</p>
<p>在一个地方待得太久，就会渐渐的忘记时间，曾经以为这样的日子会长久，但终究在这样一个宁静的午后戛然而止。我们各自背上行囊，或许道一声珍重，或许相顾无言，各自奔走天涯。多年以后，你是否会记得那个喧嚣或者沉默的下午，那个远去的背影消失在遥远的尽头，那趟踏上远方的列车，我们各自转身，不再回头。可叹人世多错过，两人彼此遍寻不着，只存一份念想；淡淡的眷恋潜浮于眸，深深的情愫隐藏于心，在时间里慢慢发酵，酝酿出那一番醇香。王家卫导演在解释《一代宗师》张震的戏份太少时曾说过，有时候生命中遇见一些人，但之后就再也没见到过了，这是一部分的人生。</p>
<p>我们从久远走来，相濡以沫或者相忘于江湖，江南说：江湖是这么一个地方，你在这里生，也不介意在这里死去。可你想过没有，多年以后，或许江湖还是那个江湖，你已不是当年的那个你，曾经的那些美好都成为了过往，就算时光真的可以倒流，你会发现，一切早已经面目全非。所有的相遇，都是久别重逢，那么所有的重逢，都是时光之约，里面装满了风尘与岁月。</p>
<p>最后，这些东西都慢慢的幻化成回忆，这个世界有太多我们无能为力的东西，回不到的过去，无法预知的未来，以及那些那些再也没有见到过的人……</p>
<p>如果哪天那些人和你从此不会再见了，不是有一些新的人取而代之了，新的阶段出现了，就是遥远的我们都“懒”了。</p>
<p>曲终人会散，人走茶会凉，最后，收拾心情，背上行囊，继续上路。</p>
<p>文/阿飞 <a href="http://www.douban.com/note/295698799/" target="_blank">http://www.douban.com/note/295698799/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/09/01/missing-you/" data-id="vgxdh17kom7kxa0x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-can-not-read-cpuid-via-jlink-in-iar" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/04/can-not-read-cpuid-via-jlink-in-iar/" class="article-date">
  <time datetime="2014-06-04T07:18:27.000Z" itemprop="datePublished">Jun 4 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/教程/">教程</a>►<a class="article-category-link" href="/categories/教程/IAR/">IAR</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/04/can-not-read-cpuid-via-jlink-in-iar/">IAR环境下，Jlink调试报错，提示&lt;无法读取CPUID&gt;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="问题描述">问题描述</h3>
<p>在IAR 6.3中，使用Jlink调试Cortex-M芯片的时候，无法正常调试，报错</p>
<pre><code>Can <span class="operator">not</span> <span class="built_in">read</span> CPUID
</code></pre><p>为CPU重新上电，则可以正常进入调试状态</p>
<h3 id="出现原因">出现原因</h3>
<p>IAR Jlink DLL版本过低</p>
<h3 id="解决方案">解决方案</h3>
<p>用最新版的<code>JlinkARM.dll</code>替换掉IAR安装目录下默认的<code>JLinkARM.dll</code></p>
<p>附：我的jlinkarm.dll路径如下，不同电脑路径可能不一致，注意区分</p>
<p>1：Jlink软件JlinkARM.dll路径</p>
<pre><code>C:<span class="command">\Program</span> Files (x86)<span class="command">\SEGGER</span><span class="command">\JLinkARM</span>_V474b
</code></pre><p>2：IAR安装目录JlinkARM.dll路径</p>
<pre><code>C:<span class="command">\Program</span> Files (x86)<span class="command">\IAR</span> Systems<span class="command">\Embedded</span> Workbench 6.0<span class="command">\arm</span><span class="command">\bin</span>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/06/04/can-not-read-cpuid-via-jlink-in-iar/" data-id="9wicoh6khnb0nx4x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IAR/">IAR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jlink/">Jlink</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-personal-and-platform" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/29/personal-and-platform/" class="article-date">
  <time datetime="2014-05-29T04:48:16.000Z" itemprop="datePublished">May 29 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/转载/">转载</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/29/personal-and-platform/">个人与平台</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>


<p>总结自己短暂却又不失跌宕的职业生活（没敢说生涯），尤其到了今年，所有重要抑或不重要的故事勾勒出一幅画面。随着自己的不断进步，却发现越来越多的无奈，不断坚持后，又随着事务的不断解决，越来越悟出一个道理：个人，要想进步，必须要有个适合你的平台。</p>
<footer><strong>divivy</strong><cite><a href="http://blog.sina.com.cn/divivy" target="_blank">Divivy's Heaven</a></cite></footer></blockquote>



<pre><code>注：原文转载自 &lt;http://blog<span class="preprocessor">.sina</span><span class="preprocessor">.com</span><span class="preprocessor">.cn</span>/s/blog_414bbec30100gepf<span class="preprocessor">.html</span>&gt; ，转载请注明原出处
</code></pre><p>有朋友EMAIL我说：“我现在在的公司里我能力最强（我笑），每天干的最多，老板是很倚重我，但又不肯给我想要的待遇。不想做了，跳一跳，到时候让老板知道没我了他会多后悔。”  </p>
<p>我没正面回应他，因为我知道那种感觉不是几句话能够说动的。后来他告诉我说，他走了，去了另外一个公司，发现事情有些不按照自己想法前进。新的公司更加过分，原来的公司在自己走了后自己本来一个部门的竞争对手竟然升到了部门经理，待遇直接翻倍了。不胜后悔！</p>
<p>对于这种事情，我个人是有着切身体会的。在毕业后第一个公司时，每天我做的最多的事情就是感慨自己的“怀才不遇”，认为自己应该是理所应当的领导，为什么却要天天去做那些随便一个初中生都可以做的琐碎工作。于是消极抵抗，甚至无心工作，最后结果是一些小的事情都做不好，却让领导更加反感。最后选择离开！</p>
<p>公司的老总在我离职后也许嗅到了一些味道，两个同来的都迅速的升职，一个做项目经理一个做了技术部副经理，待遇也是随之上涨。当然我并不后悔，不过这也是后话了。当时还是有些小后悔的！</p>
<p>以上两个故事说明一个什么问题呢？那就是：<strong> 对于一个公司，你自己远远没有你想的那么重要！</strong></p>
<p>如果有合作公司老板打电话给你要你过去，待遇要比现在高，你怎么办？我的直观反应会是：“你要知道你是凭借什么才有这种资格接到这种电话。当然，你的努力和能力很重要，但是如果没有公司这个大平台，你会有今天吗？没有今天，你怎么能让别人认可你。人要学会感恩。即使对方开出的价码实在让你无法拒绝，但是你还要考虑一个你过去后能够适应的问题。”</p>
<p>再就是在个体中表现最为强烈的一种“意识形态”了。对于成立时间并不长的公司，人才，尤其是合适的人才是非常重要的。不一定要求对方的能力强到世界第一，而是要合适。公司从成立到现在，发掘了很多“合适”的人才。他们在进公司后，凭借自身努力和公司提供的宽松环境，将自己的能力发挥的淋漓尽致，为公司成长立下了汗马功劳的同时，个人能力也不断进步。</p>
<p>新公司局限于资源和自身条件，很难去储备较多的管理人才。所以招来的每个人都是依据公司缺人的职位，不断甄选，最终找到符合该职位的人选，可谓“一个钉子一个铆”。这样造成的结果有正反方面两个，一是这个人越来越合适这个工作，工作手法越来越熟练，越来越得心应手，效率更高；另一方面，随着公司的更加倚重，他听到的夸赞越来越多。这种夸赞渐渐就让人内心深处出现了“骄傲”的情绪，滋长着“没我不行”的呐喊。<br>这时候对于双方，无论公司或者个人，都是比较危险的时刻。</p>
<p>对于个人，因为觉得自己的“不可或缺”，就会产生多种复杂思维。就好像一个得了“肥胖症”的患者，接下来就会诱发如高血压、高血脂、高血糖、糖尿病等各类并发症。他们会理所当然的认为自己既然如此重要，那么老板你要提高我的职位，你要给我更高的待遇，你要给我更大的管理权力，你要给予我更多的尊重；他们会在和同事相处时表现的更加咄咄逼人，更加的骄傲和难以接受；他们会在处理工作时表现的更加眼高手低，觉得自己应该做更高一层的职位。武断的自我抬高会让自己的虚荣心不断上升，处理事务更加的独断和难以接受，他们会尝试着插手别人的分内事务，从而引起同事的不满，继而是失误的增多和更多的人心向背。</p>
<p>对于公司，培养一个合适的人选不容易。看着自己辛苦培养出来的人如此的自我膨胀，却无计可施。因为你不可能答应他的条件，否则以后他会更加不可一世，别人看到后也会群起而仿效。但是看着他越滑越远，最难过的应该是公司一方。如果这个人走了，结果应该是“双输”。</p>
<p>但是个人请永远不能低估公司作为一个平台的强大造血功能和新陈代谢能力。新公司对于一个“合适”的人离去是可以接受的，因为所有“合适”的人在同时间离开可能性不是没有，但概率却是很小的。你走了，我需要做的也许只是去再招人。也许短时间内会有些贫血，但只要人找到了，再经过培养，依然可用，造血只是个迟早的过程。而平台其他血细胞，在这种关键时刻也是完全可以到达失血位置支援的。</p>
<p>这个时候我们返回来去思索一下，作为一个个体，应该如何正确处理自己作为一个和公司这个平台的关系。总结自己的个人经验，提出如下几点：</p>
<h3 id="一、打倒自己心中的鬼，让自己变得一文不值">一、打倒自己心中的鬼，让自己变得一文不值</h3>
<p><strong>记住，不管到哪里，什么时候，自己永远没有自己想的那么重要</strong>。没有那个地方没你不行，没你地球照转，太阳天天东升西落。千万不要让自己觉得自己可以扭转地球自转的规律。平台是个大机器，而且随着不断进步，内部机械运转更加趋于合理，强大的机制才是真正的内核和发动机。个体只不过是这个巨大机器上的一颗螺丝钉，螺丝钉之于发动机，相差了N个数量级样的光年。平台和个人同时发展，大家各司其职，发动机性能更加优越，螺丝钉越来越牢固，机器运转才会越来越稳定。你有没有想起雷锋叔叔？</p>
<h3 id="二、做好自己分内的事，先把平台推上去">二、做好自己分内的事，先把平台推上去</h3>
<p>一个人的价值体现是随着平台的不断进步而不断提高的。试想现在你是一个一文不名的小公司项目经理，没人知道你，你说出去别人会说：“你们能按月发工资吗？”若干年后，你的公司成了万科级别的公司，别人看你那叫高山仰止。要想自己站得高，首先要先努力把平台推上去。做好自己分内的工作，同时尽量站在自己上一级领导的位置去思考，你能取得平台和个人同步提升。</p>
<h3 id="三、平台有多高，你就能看多远">三、平台有多高，你就能看多远</h3>
<p>也就是常说的“屁股决定脑袋”。如果你仅仅是个小职员，你认识的人就很难有项目经理或者部门主管。如果你是项目经理，你也很难接触到其他公司的高管或者老总。但是如果把你放在高官的位置，你处理事务时，思路就会比站在项目经理或者普通职员位置上更加开阔。这时，你就能理解，为什么有时候接到上边的指令之初会觉得难以执行，但做着做着就渐渐的开始佩服。当然，给你这个平台，前提是你要有相当的能力。给一个科员水平的人去坐处长的位子，那叫勉为其难，那不是在提拔人，是在糟践人。</p>
<h3 id="四、永远不要骄傲">四、永远不要骄傲</h3>
<font color="red"> <strong> 一个人成功的程度，取决于其控制性格中不好方面的能力。</strong> </font>

<p>骄傲，是所有人都有的性格。但是就像自负和自信一样，稍不留意，你就会骄傲的让自己摸不到头脑。骄傲，会让你失去细心，严谨，脚踏实地等一系列的优秀性格，你会觉得自己不可一世。</p>
<p>也许你还没有到觉得“没你不行”的地步，但是你自己想想自己是否有以下表现中的一种或者几种：</p>
<ul>
<li>你是不是越来越不想听你上级的指令了，越来越觉得他是错的</li>
<li>你是不是越来越懈怠，可以玩物丧志，可以不重视公司的纪律</li>
<li>你是不是越来越听不进别人的话了，对上级的指令感觉越来越刺耳</li>
<li>你是不是越来越开始游离于公司管理制度的灰色地带</li>
<li>你是不是开始对同级或者下属在生活中开始更多“命令式”的说话</li>
</ul>
<p>自控和自我反省能力是一个人要做好事情的基本前提。尤其对于“塑形期”的年轻人。尤其现代社会，压力大，人会变得越来越浮躁，没有方向感和归属感。所以要多看书，多学习，多做有意义的事情，切忌不要沉迷于某种不好的事物或者情绪中。</p>
<p>世界因你而动，follow your heart，多倾听自己内心的声音，让自己变得更加的强大后，你才会有更多维和正确的选择观。</p>
<p>让我们一起努力吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/05/29/personal-and-platform/" data-id="wp32m5bydxiyf46j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sublimetext-plug-doxydoc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/29/sublimetext-plug-doxydoc/" class="article-date">
  <time datetime="2014-05-29T00:18:37.000Z" itemprop="datePublished">May 29 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/教程/">教程</a>►<a class="article-category-link" href="/categories/教程/SublimeText/">SublimeText</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/29/sublimetext-plug-doxydoc/">SublimeText 插件 -- DoxyDoc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介">简介</h2>
<p>DoxyDoc是一款C++语言的Doxygen插件，有了它，你可以在SublimeText中快速插入注释，极大的提高效率</p>
<p>其它同类的插件有 <a href="https://github.com/SublimeText/PhpDoc" target="_blank">PhpDoc</a> 和 <a href="https://github.com/spadgos/sublime-jsdocs" target="_blank">DocBlockr</a></p>
<h2 id="安装">安装</h2>
<ol>
<li>按<code>Ctrl+Shift+P</code> 调出命令栏</li>
<li>输入<code>Install Package</code>执行包安装命令</li>
<li>输入<code>DoxyDoc</code>，然后点击确定，等待安装结束</li>
</ol>
<h2 id="用法">用法</h2>
<p>DoxyDoc会自动判断上下文环境，添加不同的注释格式，具体来说，包括两种</p>
<ol>
<li>注释处没有函数或变量，则自动创建空白注释</li>
</ol>
<p><img src="/images/2014/05/29/01.gif" alt=""></p>
<ol>
<li>注释处有函数或变量，则根据函数信息自动填充对应的注释部分<br>其中函数信息包括：函数名，传入参数，返回值</li>
</ol>
<p><img src="/images/2014/05/29/02.gif" alt=""><br><img src="/images/2014/05/29/03.gif" alt=""><br><img src="/images/2014/05/29/04.gif" alt=""><br><img src="/images/2014/05/29/05.gif" alt=""></p>
<h2 id="更多信息">更多信息</h2>
<p>请参考：<a href="https://sublime.wbond.net/packages/DoxyDoc" target="_blank">https://sublime.wbond.net/packages/DoxyDoc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/05/29/sublimetext-plug-doxydoc/" data-id="o17r861vneelhgsw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-table-space-configure-in-sublime-text3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/28/table-space-configure-in-sublime-text3/" class="article-date">
  <time datetime="2014-05-28T01:21:27.000Z" itemprop="datePublished">May 28 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/教程/">教程</a>►<a class="article-category-link" href="/categories/教程/SublimeText/">SublimeText</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/28/table-space-configure-in-sublime-text3/">在Sublime Text中设置Tab-Space</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1:_概述">1: 概述</h3>
<p>缩进设置决定了tab符缩进的大小，控制tab键是插入tab符号还是空格。除了自动检测之外，它们可以自定义为全局，某种文件类型，或者某个文件。</p>
<h3 id="2:_设置">2: 设置</h3>
<pre><code>|---------------------------|--------------------------------------------------------------------------------------------------------------|
<span class="localvars">|tab_size                   |</span> 数字。插入的空格数                                                                                           |
<span class="localvars">|translate_tabs_to_spaces   |</span> <span class="class">Boolean</span>, 如果为<span class="keyword">true</span>，按tab键将会输入空格替代，而不是tab字符                                                  |
<span class="localvars">|detect_indentation         |</span> <span class="class">Boolean</span>, 默认为<span class="keyword">true</span>, tab_size和translate_tabs_to_spaces将会在文件载入是自动计算                              |
<span class="localvars">|use_tab_stops              |</span> <span class="class">Boolean</span>, 如果translate_tabs_to_spaces为<span class="keyword">true</span>, use_tab_stops将会使tab和backspace在下一个tab停止时insert/delete |
</code></pre><h3 id="3:_配置文件">3: 配置文件</h3>
<p>配置文件将会按下面这个顺序应用：</p>
<ol>
<li>Packages/Default/Preferences.sublime-settings</li>
<li>Packages/Default/Preferences (<platform>).sublime-settings</li>
<li>Packages/User/Preferences.sublime-settings</li>
<li>Packages/<syntax>/<syntax>.sublime-settings</li>
<li>Packages/User/<syntax>.sublime-settings</li>
</ol>
<p>通常情况下，你应该把你的配置放在<code>Packages/User/Preferences.sublime-settings</code>里。如果你要给特定的文件类型指定配置，比如，Python, 应该放在<code>Packages/User/Python.sublime-settings</code>文件中</p>
<h3 id="4:_配置文件示例">4: 配置文件示例</h3>
<p>试着把这些保存为<code>Packages/User/Preferences.sublime-settings</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>{
    "<span class="attribute">tab_size</span>": <span class="value"><span class="number">4</span></span>,
    "<span class="attribute">translate_tabs_to_spaces</span>": <span class="value"><span class="literal">false</span>
</span>}
</pre></td></tr></table></figure>

<h3 id="5:_单独语法配置">5: 单独语法配置</h3>
<p>可以在基础配置之上指定单独的语法配置。在<code>Preferences/Settings - More/Syntax Specific - User</code>菜单下</p>
<h3 id="6:_缩进的检测">6: 缩进的检测</h3>
<p>当一个文件载入时，它的内容会被检查，<code>tab_size</code>和<code>translate_tabs_to_spaces</code>设置将会应用到该文件。状态栏将会报告发了什么。尽管编辑器会处理的很好，如果想要把它禁用的话，可以通过<code>detect_indentation</code>来设置</p>
<p>缩进检测可以手动执行，通过<code>View/Indentation/Guess Settings From Buffer</code>菜单执行<code>detect_indentation</code>命令</p>
<h3 id="7:_Tab和空格之间转换">7: Tab和空格之间转换</h3>
<p><code>View/Indentation</code>菜单里有命令可以将当前文件中的空白在tab符和空格符之间转换。这几个菜单项执行的是<code>expand_tabs</code>和<code>unexpand_tabs</code>命令</p>
<h3 id="8:_自动缩进">8: 自动缩进</h3>
<p>自动缩进猜测会在换行时给每一行添加一定数量空白符。由下面这个配置控制：</p>
<pre><code>|-------------------------------|-----------------------------------------------------------------------------------------------------------|
<span class="localvars">| auto_indent                   |</span> <span class="class">Boolean</span>, 默认是开启                                                                                       |
<span class="localvars">| smart_indent                  |</span> <span class="class">Boolean</span>, 默认是开启。具有一点小聪明的自动缩进，比如，在一个if语法片段的下一行进行缩进                     |
<span class="localvars">| trim_automatic_white_space    |</span> <span class="class">Boolean</span>, 默认开启。当断行时由auto_indent去除行头尾的空白                                                  |
<span class="localvars">| indent_to_bracket             |</span> <span class="class">Boolean</span>, 默认禁用。缩进时根据第一个前括号来空白数。像下面这样：use_indent_to_bracket(to_indent,like_this) |
</code></pre><h3 id="9：注意事项">9：注意事项</h3>
<font color="red" > 修改配置文件后，需要关闭所有打开的文件，然后重启Sublime Text </font>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/05/28/table-space-configure-in-sublime-text3/" data-id="nnscuf1g92xdojo3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-solove-sublimetext-3-chinese-encoding-problem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/27/how-to-solove-sublimetext-3-chinese-encoding-problem/" class="article-date">
  <time datetime="2014-05-27T01:13:46.000Z" itemprop="datePublished">May 27 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/27/how-to-solove-sublimetext-3-chinese-encoding-problem/">解决Sublime Text 3中文乱码问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>打开Sublime Text 3，按<code>Ctrl+～</code>打开控制行，复制粘贴以下python代码，然后回车运行</li>
</ol>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'7183a2d3e96f11eeadd761d777e62404e330c659d4bb41d3bdf022e94cab3cd0'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)
</pre></td></tr></table></figure></p>
<ol>
<li><p>重启Sublime Text 3</p>
</li>
<li><p>按<code>Ctrl+Shift+P</code>打开命令行，输入<code>Install Package</code>，回车，然后继续输入<code>ConvertToUTF8</code>，回车</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/05/27/how-to-solove-sublimetext-3-chinese-encoding-problem/" data-id="r046dz2jsicqp0k0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sublime text/">sublime text</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-promotion-of-arm-cortex-m-mcu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/22/promotion-of-arm-cortex-m-mcu/" class="article-date">
  <time datetime="2014-04-22T07:16:22.000Z" itemprop="datePublished">Apr 22 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/杂谈/">杂谈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/22/promotion-of-arm-cortex-m-mcu/">ARM CMSIS-M芯片推广文案分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ARM Cortex-M主页有个栏目叫：<strong><a href="http://www.arm.com/zh/products/processors/cortex-m/index.php" target="_blank">为什么选择Cortex-M</a></strong></p>
<p>一般情况下，特定产品都有目标群体，群体有自己的利益点，同时各方利益互有冲突。怎么有效抓住各方利益点，同时不引起冲突，这里面有个巧妙的平衡关系，非常难以把握</p>
<p>而ARM的推广语，目标定位精准，同时抓住各方利益点和兴趣点，不失为一个经典案例</p>
<p>下面对此做一个简略分析</p>
<p>首先分析ARM Cortex-M的目标群，目标群离不开生态环境，ARM的生态环境构成包括：</p>
<p>上游：各大半导体厂商<br>中游：开发工具，供应链，代工厂<br>下游：开发者，IT公司，消费者</p>
<p>各方利益点和兴趣点：<br>上游：借助ARM生态环境，推广自己的Cortex-M芯片<br>中游：成为中间不可或缺的一环，类似拦河大坝的角色<br>下游：开发难度，代码重用性，快速上市</p>
<p>ARM Cortex-M的标准推出，方便了开发者，削减了差异化程度，从而减低上游和中游的进入门槛</p>
<p>也就是说，ARM的核心思路是想法设法画牢笼（制规则，标准），同时利用利益吸引更多的人进入牢笼，从而造成各方相互抗衡局面，ARM坐收渔利。上游和中游是被逼无奈，不得不接受标准，加入战斗；下游有机会进入中上游，从而知道推广的重点群体是：</p>
<p>1）下游开发者<br>2）希望进入中上游的群体</p>
<p>下游的进入，势必威胁中上游生态，从而起到倒逼半导体和开发工具效果</p>
<p>那么，二者的利益点是什么呢？</p>
<p>1） 下游开发者的核心利益是：快速出产品，降低产品开发难度和后期维护成本<br>当然，这是站在老板的角度来说的，对于IT工程师，怎么避免学习成本才是他们关心的</p>
<p>2） 希望进入中上游的群体<br>更关心IC的成本，也就是硅面积；同时关心这个MCU的市场热度</p>
<p>ok，分析到这里，再看看ARM是怎么宣传Cortex-M芯片的</p>
<blockquote>
<p><strong>业界标准</strong><br>ARM Cortex-M 处理器树立了全球微控制器的标准，40 多个 ARM 合作伙伴已获得这些处理器的使用许可，其中包括 Freescale、NXP Semiconductors、STMicroelectronics、Texas Instruments 和 Toshiba 等领先供应商。通过采用标准处理器，ARM 合作伙伴可制造出具有统一架构的设备，同时能够专注于各自差异化的设计。</p>
<p><strong>更小的代码处理器芯片</strong><br>更低的硅成本<br>高密度指令集<br>比 8/16 位设备每字节完成更多操作<br>更小的 RAM、ROM 或闪存要求</p>
<p><strong>高性能</strong><br>更有竞争力的产品<br>Powerful Cortex-M processor<br>每 MHz 提供更高的性能<br>能够以更低的功耗实现更丰富的功能</p>
<p><strong>能效能效</strong><br>更低的功耗，更长的电池寿命<br>以更低的 MHz 或更短的活动时段运行<br>基于架构的睡眠模式支持<br>比 8/16 位设备的工作方式更智能、睡眠时间更长</p>
<p><strong>易用使用</strong><br>更快的软件开发和重用<br>多个供应商之间的全球标准<br>代码兼容性<br>统一的工具和操作系统支持</p>
</blockquote>
<p><strong>高性能</strong>，<strong>能效能效</strong>，<strong>易用使用</strong> 主要针对目标群1）的利益点和关切点</p>
<p><strong>业界标准</strong>，<strong>更小的代码处理器芯片</strong> 主要针对目标群2）的利益点和关切点</p>
<p><strong>附：ARM Cortex-M主页</strong></p>
<p><a href="http://www.arm.com/zh/products/processors/cortex-m/index.php" target="_blank">http://www.arm.com/zh/products/processors/cortex-m/index.php</a></p>
<p>全文完</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/04/22/promotion-of-arm-cortex-m-mcu/" data-id="kzhu5lzcewe7aubr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learning-method-in-it-field-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/22/learning-method-in-it-field-6/" class="article-date">
  <time datetime="2014-04-22T03:50:00.000Z" itemprop="datePublished">Apr 22 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/转载/">转载</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/22/learning-method-in-it-field-6/">IT人的学习方法论-6 IT专家成长的十个学习的建议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>注：<br>    1）本文出自 “喻勇的博客” 博客，转载请务必保留此出处 <a href="http://yongyu2000.blog.51cto.com/962342/214134" target="_blank">http://yongyu2000.blog.51cto.com/962342/214134</a><br>    2）在原文基础上略有修改<br>    3）原系列共7篇文章，这里将其整理为6篇</p>
<p>成长路上的十个学习建议，算是对IT人学习方法论这个系列的一个小结吧。在之前的5篇文章中，我们讨论了学习的方向、误区、建议，应该培养的能力和如何进行技术创新。下面这些建议，都是可以落到实处的“回家作业”，希望大家在学习的过程中可以有针对性的选择和应用</p>
<p><strong>1）基础知识和基本技能</strong></p>
<p>“出来混得，迟早要还”，双基是关键，选择你需要的内容，制定一个小计划和达到的目标，补一补这方面的课。这里关键是要搞清楚“需要补什么”、“明确计划”和“目标是什么”。不要盲目的恶补理论知识，搞清楚哪些东西是对自己今后的长远发展有帮助的，实在看不清方向，可以请教一些前辈，然后把他们的反馈经过你自己的独立思考以后，来确定自己缺什么。学习是一个循序渐进的过程能，要给自己制定一个计划，时刻记住我之前说的“有效学习时间”，不要三天找资料、两天买书、最后一天随便翻翻，要沉下去。凡事都要把握一个“度”，学习基础知识的目的是为了指导应用、协助创新，不是为了科学理论研究。应该知道选择、取舍，知道自己学到什么程度可以停一停了。这些“度”的把握都很微妙，没人能帮你，全靠你的独立思考</p>
<p><strong>2）提问和从他人学习</strong></p>
<p>在提问中激发灵感，在讨论中获得思想。与他人的交流，不要局限在为了解决特定的一个技术难题或者问题。不要把别人当成你的“技术支持工程师”，用开放式的问题来获得他人给你指定的方向和启发。技术人员要学会谦虚，我经常在一些技术论坛看到“文人相轻”的景象，讨论中谁也不服谁，互相拆台。计算机技术本身就是一门开放的学科，闻道有先后，术业有专攻，大家都是被技术魅力的吸引所走到一起来的，学会拥有一个包容的心态，你的收获就会更大，严于律己，宽以待人。</p>
<p><strong>3）善于总结</strong></p>
<p>建议你多使用PowerPoint和OneNotes，如果你对微软的Office产品不感冒，那就算拿一本记事本来也好。总结是思考和积累的一种方法，把你学会的东西记录在OneNotes，长期养成这样的习惯，会慢慢的积累很多。好记性不如烂笔头，多做一些笔记，把自己的想法记录下来，把想法发展为看法，形成你独特的观点。网上经常有人发一些学习笔记，这是非常好的习惯，帮助自己，也帮到了他人。总结要简单，抓住要领。可以尝试一下，如果写了一份4000字的笔记，试着让自己把它缩减到只有100字，看看是否还能够传达你想传达的信息。总结就是要把复杂问题简单化，抓住要领和关键。</p>
<p><strong>4）博采众长</strong></p>
<p>一个人的知识体系就好比一个圆球，知识越多，你这个圆球所接触到的未知世界的面积也就越大，也就越发知道自己缺少什么。丰富知识的范围，把圆球画的更大。看看自己行业以外的东西，看看你公司的经营战略，看看世界上的流行趋势，甚至看看中国的5000年历史文明，人生是一场马拉松，千万不要沉醉在技术的世界自我陶醉，坐井观天。</p>
<p><strong>5）与高手过招</strong></p>
<p>与高手过招的目的是找到自己的短处。你要瞪大眼睛寻找自己身边的高手，虚心的学习，聪明的提问，坦诚的交流，不断地总结，没有人会把你拒之门外</p>
<p><strong>6）站在巨人的肩旁上</strong></p>
<p>牛顿在1676年的一封信中说：“如果说我看得比别人更远，那是因为我站在巨人的肩上”。“与高手过招”，说的是人与人之间的交流。而“站在巨人的肩旁上”，是关于“一个平台”的选择，也就是一个关于“起点”的选择。每个人的现实情况可能各不相同，但是从长远的成功来看，一定要选择高起点。宁为凤尾，不做鸡头，好的平台，比如大学、公司等等，可以让你看的更远，有更多的机会、选择和自由度。在刚步入工作岗位时，不要仅仅考虑物质的收入，有些大公司的薪水也许并不高，但是工作一段时间后，给你带来的眼界提升，是多少钱都买不来的，这会使你变得与众不同。如果你有走出国门的海外工作机会，更不能轻言放弃，“读万卷书，行万里路”，这会给你带来更多的经历和自信</p>
<p><strong>7）三人行，必有我师</strong></p>
<p>谦虚使人进步。一些技术论坛上最常见的就是谁也不服谁的争吵，“老子技术天下第一”，决容不得他人的质疑。真正的高手，是敢于坦然地说“我不知道”并虚心请教的人。不要文人相轻，要心胸宽广，与人为善，要学会海纳百川，有容乃大</p>
<p><strong>8）勿在浮沙筑高台</strong></p>
<p>不要满足于一时的微小成就，山外有山，这个世界每一秒钟都在进步，要保持清醒的头脑，拒绝浮躁。第一次看到“勿在浮沙筑高台”，是在2001年读侯捷老师的《深入浅出MFC》的时候，短短的7个字，道出了浮躁的后果。在学习的路上，要耐得住寂寞，不能急于求成，这个道理同样也适用于为人处世，深度决定了高度</p>
<p><strong>9）实践出真知</strong></p>
<p>光把书看懂是没有用的，关键是要能应用。动口不如动手。要创造性地做一些实验，动手实验不仅仅是为了看看XX软件的功能是不是像说明书上写的那样，这是软件测试人员的工作，你不应该按照说明书来实验。在理解技术和产品的基础上，创造性地制造一些需求，并用技术来解决它，这样的一个过程，才能收获最大</p>
<p><strong>10）要知道自己需要什么</strong></p>
<p>到你找到这个问题的答案时，就不会再迷茫和浮躁。没人能帮助你寻找这个答案，只有靠自己的摸索和不断地总结，再一次次否定自己的过程中成长</p>
<p>有关学习的连载就到这里告一段落了。知易行难，我说的都是一些非常容易理解的观点，根本上来说，学习还是一个需要刻苦努力的过程，恰当的方法只是一个必要条件，要有所成就，其实归根结底还是两个字：<blod><font color="red">努力</font></blod></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cedar-renjun.github.io/2014/04/22/learning-method-in-it-field-6/" data-id="ii3tmjlv338khbk6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/archives/2014/page/2/">2</a><a class="page-number" href="/archives/2014/page/3/">3</a><a class="extend next" href="/archives/2014/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/github/octopress/">octopress</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/思维训练/">思维训练</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/推荐/">推荐</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/教程/IAR/">IAR</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/SublimeText/">SublimeText</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/框架/">框架</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程，Doxygen/">教程，Doxygen</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程，Doxygen，Markdown/">教程，Doxygen，Markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈，开源/">杂谈，开源</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载，励志/">转载，励志</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IAR/">IAR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jlink/">Jlink</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime text/">sublime text</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IAR/" style="font-size: NaNpx;">IAR</a><a href="/tags/Jlink/" style="font-size: NaNpx;">Jlink</a><a href="/tags/sublime text/" style="font-size: NaNpx;">sublime text</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09">September 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06">June 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05">May 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04">April 2014</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03">March 2014</a><span class="archive-list-count">10</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/09/21/good-blog-about-coroutines/">谈谈协程和C语言的协程</a>
          </li>
        
          <li>
            <a href="/2014/09/17/state-machine-timer-resource-management/">在状态机中管理时间资源</a>
          </li>
        
          <li>
            <a href="/2014/09/01/missing-you/">那些人，珍重便好</a>
          </li>
        
          <li>
            <a href="/2014/06/04/can-not-read-cpuid-via-jlink-in-iar/">IAR环境下，Jlink调试报错，提示&lt;无法读取CPUID&gt;</a>
          </li>
        
          <li>
            <a href="/2014/05/29/personal-and-platform/">个人与平台</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 Cedar<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript" src="/js/script.js"></script>
  </div>
</body>
</html>