<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>谈谈协程和C语言的协程 | Simple</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="注： 本文转自 http://www.yeolar.com/note/2013/02/17/coroutines/
晚上在整理我的 $HOME 的时候，发现了一段有趣的代码，它被保存为了a.c并存在了差不多半年之久。种种迹象表明，它很重要。其实我记得它，当初在网上看到，觉得它包含了一个巧妙的技巧，就让它长住在我的硬盘上了，今天我决定把它搬到这篇文章中。好吧，我是打算谈一谈协程的概念。
一个例子先给">
<meta property="og:type" content="article">
<meta property="og:title" content="谈谈协程和C语言的协程">
<meta property="og:url" content="cedar-renjun.github.io/2014/09/21/good-blog-about-coroutines/index.html">
<meta property="og:site_name" content="Simple">
<meta property="og:description" content="注： 本文转自 http://www.yeolar.com/note/2013/02/17/coroutines/
晚上在整理我的 $HOME 的时候，发现了一段有趣的代码，它被保存为了a.c并存在了差不多半年之久。种种迹象表明，它很重要。其实我记得它，当初在网上看到，觉得它包含了一个巧妙的技巧，就让它长住在我的硬盘上了，今天我决定把它搬到这篇文章中。好吧，我是打算谈一谈协程的概念。
一个例子先给">
<meta property="og:updated_time" content="2015-10-16T16:11:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谈谈协程和C语言的协程">
<meta name="twitter:description" content="注： 本文转自 http://www.yeolar.com/note/2013/02/17/coroutines/
晚上在整理我的 $HOME 的时候，发现了一段有趣的代码，它被保存为了a.c并存在了差不多半年之久。种种迹象表明，它很重要。其实我记得它，当初在网上看到，觉得它包含了一个巧妙的技巧，就让它长住在我的硬盘上了，今天我决定把它搬到这篇文章中。好吧，我是打算谈一谈协程的概念。
一个例子先给">
  
    <link rel="alternative" href="/atom.xml" title="Simple" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Do one thing and do it well</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cedar-renjun" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1995742315/profile?topnav=1&wvr=6" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/BLE4-0/" style="font-size: 10px;">BLE4.0</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/CC26xx/" style="font-size: 10px;">CC26xx</a> <a href="/tags/Debugger/" style="font-size: 12.5px;">Debugger</a> <a href="/tags/ELF/" style="font-size: 15px;">ELF</a> <a href="/tags/FPGA/" style="font-size: 10px;">FPGA</a> <a href="/tags/GPIO/" style="font-size: 10px;">GPIO</a> <a href="/tags/Hacker/" style="font-size: 12.5px;">Hacker</a> <a href="/tags/IAR/" style="font-size: 10px;">IAR</a> <a href="/tags/IDA/" style="font-size: 12.5px;">IDA</a> <a href="/tags/IU/" style="font-size: 10px;">IU</a> <a href="/tags/Jlink/" style="font-size: 10px;">Jlink</a> <a href="/tags/LPC/" style="font-size: 10px;">LPC</a> <a href="/tags/M1/" style="font-size: 10px;">M1</a> <a href="/tags/NFC/" style="font-size: 12.5px;">NFC</a> <a href="/tags/NXP/" style="font-size: 10px;">NXP</a> <a href="/tags/Nucleo/" style="font-size: 10px;">Nucleo</a> <a href="/tags/PN532/" style="font-size: 10px;">PN532</a> <a href="/tags/QT/" style="font-size: 12.5px;">QT</a> <a href="/tags/RFID/" style="font-size: 10px;">RFID</a> <a href="/tags/STM32/" style="font-size: 10px;">STM32</a> <a href="/tags/STM32F4/" style="font-size: 10px;">STM32F4</a> <a href="/tags/STM32F7/" style="font-size: 10px;">STM32F7</a> <a href="/tags/TI/" style="font-size: 10px;">TI</a> <a href="/tags/USB/" style="font-size: 20px;">USB</a> <a href="/tags/VS2013/" style="font-size: 10px;">VS2013</a> <a href="/tags/elua/" style="font-size: 10px;">elua</a> <a href="/tags/lua/" style="font-size: 10px;">lua</a> <a href="/tags/music/" style="font-size: 10px;">music</a> <a href="/tags/sublime-text/" style="font-size: 10px;">sublime text</a> <a href="/tags/公司/" style="font-size: 10px;">公司</a> <a href="/tags/微信订阅号/" style="font-size: 17.5px;">微信订阅号</a> <a href="/tags/树莓派/" style="font-size: 12.5px;">树莓派</a> <a href="/tags/示波器/" style="font-size: 10px;">示波器</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.miaoxiong.net/">喵兄</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://ahnniu.github.io/">牛工</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Cedar, 嵌入式软件工程师，玩过各种MCU，熟悉无线协议栈，USB，RTOS，半个软件架构师，最近在折腾调试器. QQ: 819280802</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Do one thing and do it well</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Do one thing and do it well</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cedar-renjun" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1995742315/profile?topnav=1&wvr=6" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-good-blog-about-coroutines" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/21/good-blog-about-coroutines/" class="article-date">
  	<time datetime="2014-09-21T09:07:39.000Z" itemprop="datePublished">2014-09-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      谈谈协程和C语言的协程
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/转载/">转载</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>注：</strong> 本文转自 <a href="http://www.yeolar.com/note/2013/02/17/coroutines/" target="_blank" rel="external">http://www.yeolar.com/note/2013/02/17/coroutines/</a></p>
<p>晚上在整理我的 $HOME 的时候，发现了一段有趣的代码，它被保存为了a.c并存在了差不多半年之久。种种迹象表明，它很重要。其实我记得它，当初在网上看到，觉得它包含了一个巧妙的技巧，就让它长住在我的硬盘上了，今天我决定把它搬到这篇文章中。好吧，我是打算谈一谈协程的概念。</p>
<h2 id="一个例子">一个例子</h2><p>先给大家看一下这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">&#125; task;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> crBegin(state) \</span><br><span class="line">        switch (state) &#123; case <span class="number">0</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> crReturn(state, ret) \</span><br><span class="line">        (state) = __LINE__; return (ret); case __LINE__:</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> crEnd() \</span><br><span class="line">        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cb</span><span class="params">(task *t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    crBegin(t-&gt;state);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        t-&gt;num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (t-&gt;i = <span class="number">0</span>; t-&gt;i &lt; <span class="number">20</span>; t-&gt;i++) &#123;</span><br><span class="line">            crReturn(t-&gt;state, t-&gt;num);</span><br><span class="line">            t-&gt;num += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    crEnd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    task t;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    t.state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, cb(&amp;t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>它会输出5组1 ~ 20的数字。是不是有点晕，我们把宏展开再看一下 cb 函数。为了便于阅读，做了一些调整：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cb</span><span class="params">(task *t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (t-&gt;state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            t-&gt;num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (t-&gt;i = <span class="number">0</span>; t-&gt;i &lt; <span class="number">20</span>; t-&gt;i++) &#123;</span><br><span class="line">                t-&gt;state = __LINE__ + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> t-&gt;num;</span><br><span class="line">    <span class="keyword">case</span> __LINE__:</span><br><span class="line">                t-&gt;num += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看清楚了吗？这其实是 switch 的一个技巧，通过它实现了一种断点的效果，类似于Python的 yield 。它是一个非常简单的C的协程实现。</p>
<h3 id="协程的概念">协程的概念</h3><p>我们再看看 Wiki上对协程的解释 ：</p>
<blockquote><p>“<br>与子例程一样，协程也是一种程序组件。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务，迭代器，无限列表和管道。</p>
<p>因为相对于子例程协程可以有多个入口和出口点，可以用协程来实现任何的子例程。事实上，正如 Knuth 所说：“子例程是协程的特例。”</p>
<p>每当子例程被调用时，执行从被调用子例程的起始处开始；然而，接下来的每次协程被调用时，从协程返回（或屈服）的位置接着执行。</p>
<p>因为子例程只返回一次，要返回多个值就要通过集合的形式。这在有些语言，如 Forth， 里很方便，而其他语言，如 C ，只允许单一的返回值所以就需要引用一个集合。相反地，因为协程可以返回多次，返回多个值只需要在后继的协程调用中返回附加的值即可。在后继调用中返回附加值的协程常被称为产生器。</p>
<p>子例程容易实现于堆栈之上，因为子例程将调用的其他子例程作为下级。相反地，协程对等地调用其他协程，最好的实现是用 continuations（由有垃圾回收的堆实现）以跟踪控制流程。</p>
<p>在当今的主流编程环境里，线程是协程的合适的替代者，线程提供了用来管理“同时”执行的代码段实时交互的功能。因为要解决大量困难的问题，线程包括了许多强大和复杂的功能并导致了困难的学习曲线。当需要的只是一个协程时，使用线程就过于技巧了。然而——不像其他的替代者——在支持 C 的环境中，线程也是广泛有效的，对很多程序员也比较熟悉，并被很好地实现，文档化和支持。<br>”</p>
</blockquote>
<p>怎么样，现在是不是明白协程是怎么回事了？</p>
<h2 id="C语言的协程">C语言的协程</h2><p>关于C语言的协程编程，PuTTY的作者Simon Tatham写有一篇很棒的 文章 ，我们的一位同行张杰在看PuTTY代码时看到了作者对协程的使用，并给文章做了一份 翻译 ，在这里把译文给出（对照原文做了一些修改），同时在此表达对两位敬意。</p>
<h3 id="介绍">介绍</h3><p>设计大型程序一直都是件困难的事情，其中常常会遇到的一个难题是：一段生成数据的代码和一段处理这些数据的代码，让哪一个做调用函数，哪一个做被调函数？</p>
<p>下面是用于游程编码的解码器代码和解析器代码，都很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Decompression code */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == EOF)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0xFF</span>) &#123;</span><br><span class="line">        len = getchar();</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">while</span> (len--)</span><br><span class="line">            emit(c);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        emit(c);</span><br><span class="line">&#125;</span><br><span class="line">emit(EOF);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parser code */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == EOF)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            add_to_token(c);</span><br><span class="line">            c = getchar();</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">isalpha</span>(c));</span><br><span class="line">        got_token(WORD);</span><br><span class="line">    &#125;</span><br><span class="line">    add_to_token(c);</span><br><span class="line">    got_token(PUNCT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两段代码都很简单，易读易懂。第一段每次调用 emit() 生成一个字符；第二段每次调用 getchar() 消费一个字符。只要能想办法在调用 emit() 和 getchar() 时能让二者互相传数据，那么就能很容易地将这两段代码连到一起，从而将解码器的输出直接送进解析器。</p>
<p>很多现代操作系统中，在两个进程或线程之间使用管道就可以实现。解码器中的 emit() 向管道中写入数据，解析器的 getchar() 在管道的另一端读出数据，简单可靠，但是却不轻量也不易移植。而且也不值得为这么简单的任务将程序拆分成几个线程。</p>
<p>本文将给出一个极具创造性的方法来解决这种结构问题。</p>
<h3 id="重写">重写</h3><p>传统的方法是改写管道任意一端的代码，使其能够被调用。下面给出了如何对上面两段代码进行改写的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decompressor</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> repchar;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> replen;</span><br><span class="line">    <span class="keyword">if</span> (replen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        replen--;</span><br><span class="line">        <span class="keyword">return</span> repchar;</span><br><span class="line">    &#125;</span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == EOF)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0xFF</span>) &#123;</span><br><span class="line">        replen = getchar();</span><br><span class="line">        repchar = getchar();</span><br><span class="line">        replen--;</span><br><span class="line">        <span class="keyword">return</span> repchar;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parser</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">        START, IN_WORD</span><br><span class="line">    &#125; state;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> IN_WORD:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c)) &#123;</span><br><span class="line">            add_to_token(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        got_token(WORD);</span><br><span class="line">        state = START;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> START:</span><br><span class="line">        add_to_token(c);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))</span><br><span class="line">            state = IN_WORD;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            got_token(PUNCT);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，你不必将两段程序都进行改写，只要改一段就行了。如果你将解码器改成上面那样，它每次调用会返回一个字符，那么只要将解析器中对 getchar() 的调用替换成对 decompressor() 的调用，就好了。相反地，如果你像上面那样改写了解析器，对每个输入字符调用一次，那么就可以将解码器中调用的 emit() 换成 parser() 。别把两个函数都改写成被调函数，除非你是想受罪。</p>
<p>其实这里已经暴露出一个问题。这两个改写过的函数都比原来的要难看。把这两个过程写成调用函数要比被调函数更易读。如果单单通过看代码来推断解析器所要解析的语法或者解码器所要处理的压缩格式，那么原来的两段代码都比改写后的代码要清晰些。所以我们最好是能不改写任何一段代码。</p>
<h3 id="Knuth的协程">Knuth的协程</h3><p>在《计算机程序设计艺术》一书中，Donald Knuth给出了一个解决这类问题的方法。他的方法是彻底抛弃栈的概念。别再考虑要有一个调用函数和一个被调函数，试着将它们想象成平等的，相互合作的。</p>
<p>用专业术语来说就是：将传统的“调用”原语用个稍微不同的“调用”来代替。这个新的“调用”能够将返回值保存在其它地方，而不是栈上，并且还能够跳转到由另一个已保存的返回值所指定的地址上。这样，解码器每次生成一个新的字符，就保存自己的程序计数器并跳转到上次离开解析器时的地址上；而对解析器来说，它每次需要一个新字符时，它保存自己的程序计数器并跳转到上一次离开解码器的地址上。程序可以这样在两个函数之间切换所需要的次数。</p>
<p>理论上，这样是不错。但实际中，我们却只能用汇编语言这么作，因为通用的高级语言没有一个支持协程调用原语。类似于C这样的语言全都要依赖于基于栈的结构，因此在函数间传递控制时，必须要有一个调用函数和一个被调函数。所以如果你想写可移植的代码，这个技术和使用Unix管道的方法一样不可行。</p>
<h3 id="基于栈的协程">基于栈的协程</h3><p>我们真正要的是找到C语言中能摹仿Knuth的协程调用原语的能力。我们必须接受这个现实：在C语言中，必须要有调用函数和被调函数。调用函数对我们来说没有任何问题，我们完全按照原算法写代码就行，无论什么时候，如果它生成(或者需要)一个字符，那就调用另外一个函数。</p>
<p>问题是出在被调函数上。对于被调函数，我们希望有一个“能从返回处再继续”的函数，也就是说从这个函数返回后，当再次调用它时，能从上次返回语句之后的位置继续运行。例如，我们希望能写出这样一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">return</span> i;   <span class="comment">/* won't work, but wouldn't it be nice */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连续对它调用10次，它能分别返回0到9.</p>
<p>我们该怎样实现呢？其实我们可以利用 goto 语句跳转到函数中的任意一点。如果我们在函数中加入一个状态变量，我们就可以这样实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i, state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">goto</span> LABEL0;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">goto</span> LABEL1;</span><br><span class="line">    &#125;</span><br><span class="line">    LABEL0: <span class="comment">/* start of function */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        state = <span class="number">1</span>; <span class="comment">/* so we will come back to LABEL1 */</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">        LABEL1:; <span class="comment">/* resume control straight after the return */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是可行的。我们在所有可能需要恢复执行的位置都加上标签：起始位置加一个，还有所有 return 语句之后都加一个。我们在状态变量中保存每次调用这个函数时的状态，这样它就能在我们下次调用时告诉我们应该跳到哪个标签上。每次返回前，更新状态变量，指向到正确的标签；不论调用多少次，针对状态变量的 switch 语句都能找到我们要跳转到的位置。</p>
<p>但这还是难看得很。最糟糕的部分是所有的标签都需要手工维护，还必须保证函数中的标签和开头 switch 语句中的一致。每次新增一个 return 语句，就必须想一个新的标签名并将其加到 switch 语句中；每次删除 return 语句时，同样也必须删除对应的标签。这使得维护代码的工作量增加了一倍。</p>
<h3 id="Duff的装置">Duff的装置</h3><p>C语言中著名的Duff装置利用了一个事实： switch 的 case 语句，即使放在 switch 的一个子块中，仍然是合法的。Tom Duff利用这一点给出了一个优化的输出循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (count % <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:        <span class="keyword">do</span> &#123;  *to = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:              *to = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:              *to = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:              *to = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:              *to = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:              *to = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:              *to = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:              *to = *from++;</span><br><span class="line">                   &#125; <span class="keyword">while</span> ((count -= <span class="number">8</span>) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以把这个技巧用在协程上。不用 switch 语句来决定要跳转到哪里去执行，而是直接利用 switch 语句本身来实现跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i, state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* start of function */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            state = <span class="number">1</span>; <span class="comment">/* so we will come back to "case 1" */</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:; <span class="comment">/* resume control straight after the return */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在看到希望了。我们要做的事情就是精心构造抽取出几个宏来，将这种看起来不伦不类的实现用一些看起来更结构化的语句隐藏起来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> crBegin static int state=<span class="number">0</span>; switch(state) &#123; case <span class="number">0</span>:</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> crReturn(i,x) do &#123; state=i; return x; case i:; &#125; while (<span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> crFinish &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    crBegin;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        crReturn(<span class="number">1</span>, i);</span><br><span class="line">    crFinish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 使用 do … while(0) 是为了确保 crReturn 出现在 if … else 之间时不需要使用大括号将它包裹起来</p>
<p>好了，这基本上就是我们想要的了。我们可以使用 crReturn 将函数返回，并能够在下次调用时从返回的位置之后继续执行。当然，我们必须要遵守几条规则（函数体要嵌在 crBegin 和 crFinish 之间；所有需要跨 crReturn 使用的局部变量都要定义成 static 变量；不能把 crReturn 放在其他 switch 语句中）；不过这几条规则对我们并没有太大限制。</p>
<p>现在就剩下一个问题了，就是 crReturn 的第一个参数。就像在上一节中我们每增加一个新的标签都要考虑防止标签名重复一样，现在我们必须保证 crReturn 的第一个参数不能相同。其实就算重名的话，后果也不严重 —— 编译器能够发现这个错误，因此不会在运行时导致严重后果 —— 但我们还是要避免这个问题。</p>
<p>这个问题是能够解决的。ANSI C提供了 <strong>LINE</strong> 宏，这个宏展开后是当前代码行的行号，接下来我们就修改一下 crReturn ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> crReturn(x) do &#123; state=__LINE__; return x; \</span><br><span class="line">                         case __LINE__:; &#125; while (<span class="number">0</span>)</span></span><br></pre></td></tr></table></figure>
<p>现在我们就不用再担心那些关于状态参数了，只是增加了第四条规则（不要将2个 crReturn 语句放在同一行）。</p>
<h3 id="评估">评估</h3><p>现在我们有了这个东西，就可以用它再来改写一下原来那两段代码了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decompressor</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c, len;</span><br><span class="line">    crBegin;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">if</span> (c == EOF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0xFF</span>) &#123;</span><br><span class="line">            len = getchar();</span><br><span class="line">            c = getchar();</span><br><span class="line">            <span class="keyword">while</span> (len--)</span><br><span class="line">                crReturn(c);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            crReturn(c);</span><br><span class="line">    &#125;</span><br><span class="line">    crReturn(EOF);</span><br><span class="line">    crFinish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parser</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    crBegin;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* first char already in c */</span></span><br><span class="line">        <span class="keyword">if</span> (c == EOF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                add_to_token(c);</span><br><span class="line">               crReturn( );</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="built_in">isalpha</span>(c));</span><br><span class="line">            got_token(WORD);</span><br><span class="line">        &#125;</span><br><span class="line">        add_to_token(c);</span><br><span class="line">        got_token(PUNCT);</span><br><span class="line">        crReturn( );</span><br><span class="line">    &#125;</span><br><span class="line">    crFinish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经把解码器和解析器都改写成了被调函数，它们不需要像上次那样的大规模的重构工作了。每个函数的结构完全是原来算法的翻版。读代码的人能够推出解析器所能识别的语法，也能推出解码器所使用的压缩格式，与读那两段使用状态机来实现的代码比起来，这要容易多了。一旦你适应了这种新的代码形式，就会发现这两段代码的控制流程相当直观：解码器产生出一个字符时，它就调用 crReturn 将这个字符传给调用函数，并等待当需要下一个字符时再次被调用；当解析器需要一个字符时，它就通过 crReturn 返回，并等待下一次被调用时通过参数 c 传入新的字符。</p>
<p>不过，代码中还是有一处小小的结构调整： getchar() （其实，在改写的代码中是 crReturn ）放在了 parser() 的循环的结尾，而不是开头，这是因为在进入函数时，第一个字符已经通过 c 传进来了。我们应该能接受这个结构上的小改动，要是你真的对此感觉强烈，可以这样认为：在开始向 parser() 送入数据之前，它需要一次初始化调用。</p>
<p>当然，和前面一样，我们不必把两个函数都用协程的宏改写。改一个就足够了，另一个可以作为它的调用函数。</p>
<p>我们已经实现了文章开始时的目标：一个可移植的ANSI C方法，解决数据在生产者和消费者之间的传递问题，而不必把代码用状态机重写。我们用 switch 语句的一个很少用到的特性，结合C语言的预处理器，构造出一个隐式的状态机，进而实现了我们的目标。</p>
<h3 id="编程规范">编程规范</h3><p>显然，这个技巧跟每本编程规范书中的内容都相悖。如果你在公司的代码中这样用，你很有可能会受到指责，并因为这种不遵守纪律的行为而被警告：你的宏定义中大括号没有匹配完整，在子代码块中包含了未用到的 case ，还有 crReturn 中乱七八糟的不完整的内容… 写出这样不负责任的代码，不炒了你才怪。你应该为此感到羞愧。</p>
<p>我要声明将编程规范用在这里是不对的。文章里给出的示例代码不是很长，也不很复杂，即便以状态机的方式改写还是能够看懂的。但是随着代码越来越长，改写的难度将越来越大，改写对直观性造成的损失也变得相当相当大。</p>
<p>想一想，一个函数如果包含这样的小代码块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> STATE1:</span><br><span class="line"><span class="comment">/* perform some activity */</span></span><br><span class="line"><span class="keyword">if</span> (condition) state = STATE2; <span class="keyword">else</span> state = STATE3;</span><br></pre></td></tr></table></figure>
<p>对于看代码的人说，这和包含下面小代码块的函数没有多大区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL1:</span><br><span class="line"><span class="comment">/* perform some activity */</span></span><br><span class="line"><span class="keyword">if</span> (condition) <span class="keyword">goto</span> LABEL2; <span class="keyword">else</span> <span class="keyword">goto</span> LABEL3;</span><br></pre></td></tr></table></figure>
<p>一个是调用函数，另一个是被调函数。是的，这两个函数的结构在视觉上是一样的，而对于函数中实现的算法，两个函数都一样不利于查看。因为你使用协程的宏而炒你鱿鱼的人，一样会因为你写的函数是由小块的代码和 goto 语句组成而吼着炒了你。只是这次他们没有冤枉你，因为像那样设计的函数会严重扰乱算法的结构。</p>
<p>编程规范的目标就是为了代码清晰。如果将一些重要的东西，象 switch 、 return 以及 case 语句，隐藏到起“障眼”作用的宏中，从编程规范的角度讲，可以说你扰乱了程序的语法结构，并且违背了代码清晰这一要求。但是我们这样做是为了突出程序的算法结构，而算法结构恰恰是看代码的人更想了解的。</p>
<p>任何编程规范，如果非要牺牲算法清晰度来换取语法的清晰度，都应该进行修改。如果你的上司因为使用了这一技巧而解雇你，那么在保安把你往外拖的时候要不断告诉他这一点。</p>
<h3 id="提炼及编码">提炼及编码</h3><p>在正规的应用程序中，这个协程的实现很少能用得上，因为它用到了静态变量，因此是不可重入的，也不能支持多线程。理想情况下，在一个实际的应用程序中，你会希望能在几个不同的上下文中调用同一个函数，并且每次在某个上下文中调用这个函数时，都能在这个上下文中上一次返回的位置之后恢复执行。</p>
<p>这非常容易实现。我们给函数增加一个新的参数，一个指向上下文结构体的指针；我们将所有的局部变量还有协程用到的状态变量都声明成结构体中的元素。</p>
<p>这确实有点难看，因为你突然不能用 i 作为循环计数，而要用 ctx-&gt;i ；事实上，所有重要的变量都成了协程上下文结构体中的成员。但是，这解决了重入的问题，并且没影响到函数的结构。</p>
<p>（当然，要是C语言支持Pascal语言的 with 语句，我们就可以将这个间接的引用隐藏掉。但是很遗憾。而对于C++语言，我们可以把协程的两个函数设计成类的成员函数，所有的局部变量设计成类的成员变量，从而将作用域的问题隐藏掉。）</p>
<p>这里引用的C语言头文件实现了一套预定义的协程使用的宏。文件中定义了2套宏函数，前缀分别是 scr 和 ccr 。 scr 宏是一套简单的实现，用于可以使用静态变量的情况； ccr 宏更高级一些，能支持重入。在头文件的注释中有完整的说明。</p>
<p>需要注意的是，VC++ 6并不喜欢这种协程技巧，因为其默认的debug状态（Program Database for Edit and Continue）对 <strong>LINE</strong> 宏的支持有点儿怪。如果想用VC++ 6编译一个使用了协程的宏，你就要关掉Edit and Continue。（在project settings中，选择c/c++标签，在General中，将Debug info改为Program Database for Edit and Continue之外的其他值)。</p>
<p>（这个头文件是MIT许可的，所以你可以任意使用，没有任何限制。如果你发现MIT对你的使用方式有限制，可以给我发邮件，我会考虑给你授权。）</p>
<p>使用 这个链接 获得coroutine.h。</p>
<p>感谢您的阅读。共享并享受共享吧！</p>
<h3 id="参考文献">参考文献</h3><ul>
<li><p>Donald Knuth, The Art of Computer Programming, Volume 1. Addison-Wesley, ISBN 0-201-89683-4. Section 1.4.2 描述了协程的最原始的形式。</p>
</li>
<li><p><a href="http://www.lysator.liu.se/c/duffs-device.html" target="_blank" rel="external">http://www.lysator.liu.se/c/duffs-device.html</a> 是Tom Duff自己对Duff装置的讨论。注意，文章的最后似乎暗示了Duff自己也发明了这种协程或者类似的技巧。<br><br>2005-03-07更新： Tom Duff在一篇博客的评论中确认了 ，在他原来的邮件中写到：”一种叛逆的使用 switch 语句的方法来实现中断驱动的状态机”，这实际上和我在这里描述的方法是一样的。</p>
</li>
<li><p>PuTTY 是一个Win32的Telnet和SSH的客户端软件。其中的SSH协议的实现就是使用协程技巧的一个示例。就我目前所知，这部分代码是正规工程的代码中，最难hack的C代码。</p>
</li>
</ul>
<h3 id="结语">结语</h3><p>好了，Simon大叔的话说完了。大家鼓掌，太精彩了！当然，这个技巧的用途不广，但是这篇文章非常详细地解释了协程的概念和实际场景，以及在C语言中的一些解决思路。</p>
<p>现在回过头来看开始的那段代码，你就完全明白了吧。（我终于把a.c清理出去了）</p>
<p>关于协程的话题就到此为止，感兴趣可以看看Wiki上列出的一些使用了协程概念的语言和库。比如Erlang、Lua、Stackless Python。</p>
<h3 id="引用和参考资料">引用和参考资料</h3><ul>
<li><a href="http://www.oschina.net/code/snippet_116913_14796" target="_blank" rel="external">http://www.oschina.net/code/snippet_116913_14796</a></li>
<li><a href="http://zh.wikipedia.org/wiki/协程" target="_blank" rel="external">http://zh.wikipedia.org/wiki/协程</a></li>
<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank" rel="external">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_55119d4d0100ono5.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_55119d4d0100ono5.html</a></li>
<li><a href="http://bbs.chinaunix.net/thread-1833313-1-1.html" target="_blank" rel="external">http://bbs.chinaunix.net/thread-1833313-1-1.html</a></li>
<li><a href="http://www.cnblogs.com/edwardlost/archive/2010/11/02/1861742.html" target="_blank" rel="external">http://www.cnblogs.com/edwardlost/archive/2010/11/02/1861742.html</a></li>
<li><a href="http://www.yeolar.com/note/2013/02/17/coroutines/" target="_blank" rel="external">http://www.yeolar.com/note/2013/02/17/coroutines/</a></li>
</ul>
<p><strong>后注：</strong><br>感谢作者Simon写出这篇精彩博文，<a href="http://www.yeolar.com/" target="_blank" rel="external">http://www.yeolar.com/</a>这里有更多精品，感兴趣的同学可以关注一下</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/09/23/analysis-of-zigbee-led-module/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Z-Stack协议栈分析-LED模块
        
      </div>
    </a>
  
  
    <a href="/2014/09/17/state-machine-timer-resource-management/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">在状态机中管理时间资源</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="good-blog-about-coroutines" data-title="谈谈协程和C语言的协程" data-url="cedar-renjun.github.io/2014/09/21/good-blog-about-coroutines/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"cedar-renjun"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Do one thing and do it well
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>